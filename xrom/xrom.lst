   1:			;==============================================================================
   2:			; XROM for Jupiter-II Expansion
   3:			; 2020-Aug - Ricardo F. Lopes
   4:			; 
   5:			; Compile using Z80 ZMAC assembler: zmac xrom.z --oo lst,cim
   6:			;==============================================================================
   7:			
   8:			; Patch to the original Jupiter Ace ROM to link to this code
   9:			;   008E: C3 00 C0 00
  10:			; That patch inserts XROM in the original ROM initialization process flow
  11:			; Original Jupiter Ace ROM code:
  12:			;   008E: ED 56      IM 1      ; Set Interrupt mode 1
  13:			;   0090: 18 09      JR $009B  ; Quit to FORTH
  14:			; Code after patch applied:
  15:			;   008E: C3 00 C0   JP $C000  ; Redirect to XROM code
  16:			;   0091: 00         NOP       ; ---
  17:			
  18:			    .z80
  19:				.TITLE XROM
  20:			
  21:			;-----------------------------
  22:			; Memory Locations
  23:	C000          	XROM        .EQU $C000  ; XROM image offset
  24:	3000          	XDICT       .EQU $3000  ; RAM area where extra FORTH words will reside
  25:	8000          	PAGEDRAM    .EQU $8000  ; RAM paging above this address
  26:	2400          	SCRNRAM     .EQU $2400  ; Screen Memory (video circuit priority)
  27:	2700          	PADEND      .EQU $2700  ; End of PAD marker
  28:	2C00          	CHARRAM     .EQU $2C00  ; Character Set RAM Memory (video circuit priority)
  29:	3C18          	RAMTOP      .EQU $3C18  ; System Variable: 2 bytes, RAM top address + 1
  30:	3C1C          	SCRPOS      .EQU $3C1C  ; System Variable: 2 bytes, Next print position in video RAM
  31:	3C47          	FORTH_LF    .EQU $3C47  ; FORTH word Link Field: point to last word Name Length Field
  32:	1D58          	UFLOAT_NLF  .EQU $1D58  ; UFLOAT word Name Length Field (last word in original ROM)
  33:	3C3B          	SPARE       .EQU $3C3B  ; System Variable: 2 bytes, TOS Address + 2
  34:			;-----------------------------
  35:			; Lower ROM routines
  36:	009B          	quitToForth .EQU $009B  ; FORTH QUIT
  37:	0336          	scanKbrd    .EQU $0336  ; Keyboard Scan, return key code in Accumulator, 0 if no key pressed
  38:	084E          	forthPopBC  .EQU $084E  ; Pop Top of Stack to BC register (affects HL)
  39:			;-----------------------------
  40:			; I/O Addresses: UART
  41:	00E1          	UART_DATA   .EQU $E1    ; Rx/Tx buffer register
  42:	00E1          	UART_DLL    .EQU $E1    ; Divisor Latch LSB (when DLAB=1)
  43:	00E3          	UART_IER    .EQU $E3    ; Interrupt Enable Register
  44:	00E3          	UART_DLM    .EQU $E3    ; Divisor Latch MSB (when DLAB=1)
  45:	00E5          	UART_IIR    .EQU $E5    ; IN: Interrupt Identifier Register
  46:	00E7          	UART_LCR    .EQU $E7    ; Line Control
  47:	00E9          	UART_MCR    .EQU $E9    ; Modem Control
  48:	00EB          	UART_LSR    .EQU $EB    ; Line Status
  49:	00ED          	UART_MSR    .EQU $ED    ; Modem Status
  50:	00EF          	UART_SCR    .EQU $EF    ; Scratch Register
  51:			;-----------------------------
  52:			; I/O Addresses: Programmabel Sound Generator
  53:	00FD          	PSG_REG     .EQU $FD    ; Z80 I/O address of PSG register selection
  54:	00FF          	PSG_VAL     .EQU $FF    ; Z80 I/O address of PSG register value
  55:			;-----------------------------
  56:			; rogrammabel Sound Generator Registers
  57:	0007          	PSGenable   .EQU 7      ; PSG Register: Output channel enables and I/O Ports direction
  58:	000E          	PSGportA    .EQU 14     ; PSG Register: Port A (PAPAER and INK color)
  59:	000F          	PSGportB    .EQU 15     ; PSG Register: Port B (BORDER color and Memory Paging)
  60:			;-----------------------------
  61:			; some of FORTH dictionary code fields
  62:	0460          	F_HERE      .EQU $0460  ; HERE
  63:	048A          	F_BASE      .EQU $048A  ; BASE
  64:	04B6          	F_SEMICOLON .EQU $04B6  ; ;
  65:	063D          	F_FIND      .EQU $063D  ; FIND
  66:	0D51          	F_DIV       .EQU $0D51  ; /
  67:	086B          	F_DUP       .EQU $086B  ; DUP
  68:	0885          	F_SWAP      .EQU $0885  ; SWAP
  69:	0896          	F_CFETCH    .EQU $0896  ; C@
  70:	08A5          	F_CSTORE    .EQU $08A5  ; C!
  71:	08B3          	F_FETCH     .EQU $08B3  ; @
  72:	08C1          	F_STORE     .EQU $08C1  ; !
  73:	0912          	F_OVER      .EQU $0912  ; OVER
  74:	09B3          	F_DOT       .EQU $09B3  ; .
  75:	0DD2          	F_PLUS      .EQU $0DD2  ; +
  76:	0DE1          	F_MINUS     .EQU $0DE1  ; -
  77:	0E09          	F_1PLUS     .EQU $0E09  ; 1+
  78:	0E13          	F_2PLUS     .EQU $0E13  ; 2+
  79:	0EC3          	CF_DO_COLON .EQU $0EC3  ; DoColon
  80:	1011          	F_STK_WORD  .EQU $1011  ; Stack next word
  81:	104B          	F_STK_BYTE  .EQU $104B  ; Stack byte
  82:	1A0E          	DOCODE      .EQU $1A0E  ; from DO_COLON to ASM
  83:			
  84:			;==============================================================================
  85:			; Macros ======================================================================
  86:			;==============================================================================
  87:			
  88:			;-------------------------------
  89:			; Set PSG register value
  90:			PSGset .MACRO  value, register     
  91:			    LD    A, register
  92:			    OUT   (PSG_REG), A   ; Select PSG register
  93:			    LD    A, value
  94:			    OUT   (PSG_VAL), A   ; Set PSG register value
  95:			.ENDM
  96:			
  97:			;-------------------------------
  98:			; Print string at lin, col
  99:			PrintAt .MACRO lin, col, str
 100:			    LD    HL,str
 101:			    LD    DE,SCRNRAM + col + (lin * 32)
 102:				CALL  printStr
 103:			.ENDM
 104:			
 105:			;-------------------------------
 106:			; FORTH coding: Return back to FORTH
 107:			FORTHreturn .MACRO  
 108:			    JP   (IY)
 109:			.ENDM
 110:			
 111:			;-------------------------------
 112:			; FORTH coding: Pop DE from FORTH data stack
 113:			; Affects: HL
 114:			FORTHpop .MACRO
 115:			    RST  18H
 116:			.ENDM
 117:			
 118:			;-------------------------------
 119:			; FORTH coding: Push DE to FORTH Data stack
 120:			; Affects: HL
 121:			FORTHpush .MACRO 
 122:			    RST 10H
 123:			.ENDM
 124:			
 125:			;==============================================================================
 126:			; XROM ========================================================================
 127:			;==============================================================================
 128:	C000          	    .ORG    XROM
 129:			;-----------------------------  Initialize PSG
 130:	C000  3E0ED3FD	    PSGset 11110001b, PSGportA     ; PAPER = White, INK = Dark Blue
	      3EF1D3FF
 131:	C008  3E0FD3FD	    PSGset 10110011b, PSGportB     ; BORDER = Cyan, CharSet = 0, Screen = 0, Memory Page = 3
	      3EB3D3FF
 132:	C010  3E07D3FD	    PSGset 11111111b, PSGenable    ; Enable Ports A & B as outputs, disable Sound channels
	      3EFFD3FF
 133:			;-----------------------------  Install Character Set at FONT 0
 134:	C018  2123C4  	    LD    HL,charSet               ; Source: New Character set pattern
 135:	C01B  11002C  	    LD    DE,CHARRAM               ; Destination: Character Set RAM
 136:	C01E  010004  	    LD    BC,charSetEnd - charSet  ; Bytes to copy
 137:	C021  EDB0    	    LDIR                           ; Do copy
 138:			;-----------------------------  Install extra FORTH words
 139:	C023  2136C1  	    LD    HL,dictExp               ; Source: Extra FORTH words definition
 140:	C026  110030  	    LD    DE,XDICT                 ; Destination: Lower 1K RAM
 141:	C029  01ED02  	    LD    BC,dictExpEnd - dictExp  ; Bytes to copy
 142:	C02C  EDB0    	    LDIR                           ; Do copy
 143:			    ; Link Extra Words under FORTH word
 144:	C02E  214C32  	    LD    HL,darkLink              ; last defined extra word link field
 145:	C031  22473C  	    LD    (FORTH_LF),HL            ; Replace original FORTH link to include expanded dictionary
 146:			;----------------------------- Initialize Screen page 0	
 147:	C034  CDEFC0  		CALL   clearScreen             ; Clear screen page 0
 148:	C037  AF      	    XOR    A
 149:	C038  320027  	    LD     (PADEND),A              ; Set PAD End marker
 150:			;----------------------------- Splash Screen
 151:	C03B  3E0ED3FD	    PSGset 11111100b, PSGportA     ; PAPER = WHITE, INK = RED
	      3EFCD3FF
 152:			    ; draw 24 short red bars (12 pairs)
 153:	C043  210B24  	    LD   HL,SCRNRAM + 11  ; Screen Position destination lin=0, col=11
 154:	C046  060C    	    LD   B,12             ; Print 12 bar pairs
 155:	C048          	drawBarPair:
 156:	C048  112FC1  		LD   DE,redBar        ; Draw Bar pattern 1	
 157:	C04B  CD09C1  	    CALL drawShortBar
 158:	C04E  1130C1  		LD   DE,redBar+1      ; Draw Bar pattern 2
 159:	C051  CD09C1  	    CALL drawShortBar	
 160:	C054  2B      		DEC  HL               ; Move one screen column to the left
 161:	C055  10F1    		DJNZ drawBarPair      ; Draw next pair
 162:			    ; Draw first long red bar
 163:	C057  216E24  		LD    HL,SCRNRAM + 14 + (3 * 32) ; First bar at line 3, column 14
 164:	C05A  CD17C1  	    CALL  drawLongBar
 165:			    ; Draw second long red bar
 166:	C05D  218E24  		LD    HL,SCRNRAM + 14 + (4 * 32) ; Second bar at line 4, column 14
 167:	C060  CD17C1  	    CALL  drawLongBar
 168:			    ; Draw colors bar (INK=0..15)
 169:	C063  218826  	    LD    HL,SCRNRAM + 8 + (20 * 32) ; Color bar at line 20, column 8
 170:	C066  3EF0    	    LD    A,11110000b                ; PAPER = WHITE , INK = BLACK
 171:	C068          	colorBarLoop:                   ; loop through the 16 colors
 172:	C068  D3FF    	    OUT   (PSG_VAL),A           ; Set next INK color
 173:	C06A  3690    	    LD    (HL),90h              ; Print solid block character
 174:	C06C  23      	    INC   HL                    ; advance screen position
 175:	C06D  3C      	    INC   A                     ; next color code for INK
 176:	C06E  20F8    	    JR    NZ,colorBarLoop       ; end bar when color code wraps to zero
 177:			    ; Place Strings
 178:	C070  3EF1    	    LD    A,11110001b           ; PAPER = WHITE, INK = DARK BLUE
 179:	C072  D3FF    	    OUT   (PSG_VAL),A
 180:	C074  211FC111		PrintAt  3,  1, strJupiter  ; "Jupiter" at line  3, column  1
	      6124CD01
	      C1
 181:	C07D  2127C111	    PrintAt  4,  6, strII       ; "II"      at line  4, column  6
	      8624CD01
	      C1
 182:	C086  212AC111	    PrintAt 22, 14, strYear     ; "2020"    at line 22, column 14
	      CE26CD01
	      C1
 183:			;----------------------------- Play Initialization Tone
 184:	C08F  3E00D3FD	    PSGset       203,  0        ; Tone A period = 1ms (1kHz)
	      3ECBD3FF
 185:	C097  3E02D3FD		PSGset       203,  2        ; Tone B period = 1ms (1kHz)
	      3ECBD3FF
 186:	C09F  3E07D3FD	    PSGset 11111100b,  7        ; Channels A & B tone enabled (Left & Right channels)
	      3EFCD3FF
 187:	C0A7  3E08D3FD	    PSGset        24,  8        ; Channel A Volume = 75%
	      3E18D3FF
 188:	C0AF  3E09D3FD	    PSGset        24,  9        ; Channel B Volume = 75%
	      3E18D3FF
 189:	C0B7  3E0CD3FD	    PSGset        25, 12        ; Envelope Period = 504 ms
	      3E19D3FF
 190:	C0BF  3E0DD3FD	    PSGset 00000001b, 13        ; Envelope ramps down one cycle
	      3E01D3FF
 191:			;----------------------------- Wait Keypress to clear screen
 192:	C0C7          	waitKeyRelease:
 193:	C0C7  CD3603  	    CALL  scanKbrd
 194:	C0CA  A7      	    AND   A
 195:	C0CB  20FA    		JR    NZ,waitKeyRelease
 196:	C0CD          	waitKeyPress:
 197:	C0CD  CD3603  	    CALL  scanKbrd
 198:	C0D0  A7      	    AND   A
 199:	C0D1  28FA    	    JR    Z,waitKeyPress
 200:			;----------------------------- Select Page 1 and Font set 1, Clear Screen
 201:	C0D3  3E0FD3FD		PSGset 10111111b, PSGportB  ; BORDER = Cyan, CharSet = 1, Screen = 1, Memory Page = 3
	      3EBFD3FF
 202:	C0DB  CDEFC0  	    CALL  clearScreen
 203:			;----------------------------- Initialize Serial Communication
 204:	C0DE  011800  	    LD    BC,24        ; UART Baud rate divisor for 9600 Baud
 205:	C0E1  CD7A32  	    CALL  UartSet      ; (subroutine at XDICT space)
 206:			;----------------------------- Limit RAMTOP to unpaged RAM and QUIT to FORTH
 207:	C0E4  210080  	    LD    HL,PAGEDRAM  ; Limit FORTH to unpaged RAM region below 32768
 208:	C0E7  22183C  	    LD    (RAMTOP),HL  ; This allows for memory paging without fuss
 209:	C0EA  ED56    		IM    1            ; Select interrupt mode 1 (this was removed  in ROM patching)
 210:	C0EC  C39B00  	    JP    quitToForth  ; Quit to FORTH
 211:			
 212:			;==============================================================================
 213:			; XROM Sub routines ===========================================================
 214:			;==============================================================================
 215:			
 216:			; -----------------------------
 217:			; Clear Screen 
 218:			; -----------------------------
 219:			; Fill screen RAM with space character
 220:			; Affects: A, BC, HL, Flags
 221:	C0EF          	clearScreen:
 222:	C0EF  210024  	    LD    HL,SCRNRAM   ; Start address = first screen position
 223:	C0F2  221C3C  	    LD    (SCRPOS),HL  ; Set cursor to Home (top left screen corner)
 224:	C0F5  010003  		LD    BC,768       ; Screen positions to fill
 225:	C0F8          	clsLoop:
 226:	C0F8  3620    	    LD    (HL),$20     ; Put SPACE char at current screen position
 227:	C0FA  23      		INC   HL           ; Advance screen position
 228:	C0FB  0B      		DEC   BC           ; Count positions done
 229:	C0FC  78      		LD    A,B          ; Check if zero
 230:	C0FD  B1      	    OR    C
 231:	C0FE  20F8    		JR    NZ,clsLoop   ; keep filling until last screen position
 232:	C100  C9      	    RET
 233:			
 234:			; -----------------------------
 235:			; Print String
 236:			; -----------------------------
 237:			; HL = source string address (first byte is string length)
 238:			; DE = destination address
 239:			; Affects: A, BC, HL, flags
 240:	C101          	printStr:
 241:	C101  7E      	    LD    A,(HL)  ; Get string size
 242:	C102  4F      		LD    C,A     ; BC = string length
 243:	C103  0600    		LD    B,0
 244:	C105  23      		INC   HL      ; HL = string first character
 245:	C106  EDB0    		LDIR          ; Copy string to destination address
 246:	C108  C9      		RET
 247:			
 248:			; -----------------------------
 249:			; Draw Short Horizontal Bar
 250:			; -----------------------------
 251:			; DE = points to bar pattern
 252:			; HL = points to screen position to start drawing the bar
 253:			; Affects: A, C, DE, HL
 254:			; Output: HL = next screen line position
 255:	C109          	drawShortBar:
 256:	C109  0E06    		LD   C,6              ; Pattern is 6 chars wide
 257:	C10B          	shortBarLoop:
 258:	C10B  1A      		LD   A,(DE)           ; get char from pattern
 259:	C10C  77      		LD   (HL),A           ; put on screen
 260:	C10D  13      		INC  DE               ; Move char source pointer
 261:	C10E  23      		INC  HL               ; Move screen destination pointer
 262:	C10F  0D      		DEC  C                ; chars countdown
 263:	C110  20F9    		JR   NZ,shortBarLoop
 264:				
 265:	C112  111A00  		LD   DE,26            ; move screen pointer to next line 
 266:	C115  19      		ADD  HL,DE
 267:	C116  C9      		RET
 268:				
 269:			; -----------------------------
 270:			; Draw Long Horizontal Bar
 271:			; -----------------------------
 272:			; Draw one long horizontal bar for splash screenString print routines
 273:			; HL = screen address
 274:			; Affects: B, HL, flags
 275:	C117          	drawLongBar:
 276:	C117  0612    		LD    B,18         ; Bar length
 277:	C119          	longBarLoop:
 278:	C119  3693    		LD    (HL),93h     ; Place half block character
 279:	C11B  23      		INC   HL           ; Move to next screen position
 280:	C11C  10FB    		DJNZ  longBarLoop  ; Draw next character
 281:	C11E  C9      		RET
 282:			
 283:			;==============================================================================
 284:			; XROM Strings and constants ==================================================
 285:			;==============================================================================
 286:			
 287:	C11F  074A7570	strJupiter:  .BYTE   7, "Jupiter"
	      69746572
 288:	C127  024949  	strII:       .BYTE   2, "II"
 289:	C12A  04323032	strYear:     .BYTE   4, "2020"
	      30
 290:	C12F  14939393	redBar:      .BYTE   14h, 93h, 93h, 93h, 93h, 93h, 97h ; small graphic bar
	      939397
 291:			
 292:			;==============================================================================
 293:			; XDICT: FORTH Dictionary extension ===========================================
 294:			;==============================================================================
 295:	C136          	dictExp:
 296:			;##############################################################################
 297:	3000          	    .PHASE XDICT
 298:			;##############################################################################	
 299:			
 300:			;-------------------------------
 301:			; COUNT ( addr -- addr+1 c )
 302:			;-------------------------------
 303:			; Extract String length (code from the Jupiter Ace Manual)
 304:			; : COUNT DUP 1+ SWAP C@ ;
 305:	3000          	countName:
 306:	3000  434F554E	    .DC    "COUNT"       ; Name Field: (DC sets bit 7 of last char)
	      D4
 307:	3005  581D    	    .WORD  UFLOAT_NLF    ; Link Field: point to previous word Name Length Field
 308:	3007          	countLink:
 309:	3007  05      	    .BYTE  $ - countName - 2  ; Name Length Field
 310:	3008  C30E    	    .WORD  CF_DO_COLON        ; Code Field Address: a FORTH word
 311:			    ;----------
 312:	300A  6B08    	    .WORD  F_DUP            ; DUP
 313:	300C  090E    		.WORD  F_1PLUS          ; 1+
 314:	300E  8508    	    .WORD  F_SWAP           ; SWAP
 315:	3010  9608    	    .WORD  F_CFETCH         ; C@
 316:	3012  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 317:			
 318:			;-------------------------------
 319:			; +! ( n addr -- )
 320:			;-------------------------------
 321:			; Add 'n' to 'addr' variable (code from the Jupiter Ace Manual)
 322:			; : +! SWAP OVER @ + SWAP ! ;
 323:	3014          	pstoreName:
 324:	3014  2BA1    	    .DC    "+!"       ; Name Field: (DC sets bit 7 of last char)
 325:	3016  0730    	    .WORD  countLink  ; Link Field: point to previous word Name Length Field
 326:	3018          	pstoreLink:
 327:	3018  02      	    .BYTE  $ - pstoreName - 2  ; Name Length Field
 328:	3019  C30E    	    .WORD  CF_DO_COLON         ; Code Field Address: a FORTH word
 329:			    ;----------
 330:	301B  8508    	    .WORD  F_SWAP           ; SWAP
 331:	301D  1209    	    .WORD  F_OVER           ; OVER
 332:	301F  B308    		.WORD  F_FETCH          ; @
 333:	3021  D20D    		.WORD  F_PLUS           ; +
 334:	3023  8508    	    .WORD  F_SWAP           ; SWAP
 335:	3025  C108    		.WORD  F_STORE          ; !
 336:	3027  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 337:				
 338:			;-------------------------------
 339:			; ? ( addr -- )
 340:			;-------------------------------
 341:			; Print variable value (code from the Jupiter Ace Manual)
 342:			; : ? @ . ;
 343:	3029          	questionName:
 344:	3029  BF      	    .DC    "?"         ; Name Field: (DC sets bit 7 of last char)
 345:	302A  1830    	    .WORD  pstoreLink  ; Link Field: point to previous word Name Length Field
 346:	302C          	questionLink:
 347:	302C  01      	    .BYTE  $ - questionName - 2  ; Name Length Field
 348:	302D  C30E    	    .WORD  CF_DO_COLON           ; Code Field Address: a FORTH word
 349:			    ;----------
 350:	302F  B308    	    .WORD  F_FETCH          ; @
 351:	3031  B309    	    .WORD  F_DOT            ; .
 352:	3033  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 353:			
 354:			;-------------------------------
 355:			; CMOVE ( addr1 addr2 n -- )
 356:			;-------------------------------
 357:			; Move 'n' bytes from 'addr1' to 'addr2'
 358:	3035          	cmoveName:
 359:	3035  434D4F56	    .DC    "CMOVE"       ; Name Fieldh (DC sets bit 7 of last char)
	      C5
 360:	303A  2C30    	    .WORD  questionLink  ; Link Field: previous defined word in vocabulary
 361:	303C          	cmoveLink:
 362:	303C  05      	    .BYTE  $ - cmoveName - 2  ; Name Length Field
 363:	303D  3F30    	    .WORD  $ + 2              ; Code Field
 364:			    ;----------
 365:	303F  CD4E08  		CALL  forthPopBC   ; BC = bytes to move (from Top of Stack)
 366:	C178  DF      	    FORTHpop           ; Get destination address from Top of Stack to DE
 367:	3043  D5      		PUSH  DE           ; Save Destination address
 368:	C17A  DF      		FORTHpop           ; Get source address from Top of Stack to DE
 369:	3045  EB      		EX    DE,HL        ; HL = Source address
 370:	3046  D1      		POP   DE           ; DE = Destination address
 371:	3047  CD5F32  	    CALL  cmove        ; Move Data Block
 372:	C180  FDE9    	    FORTHreturn        ; Return back to FORTH
 373:			
 374:			;-------------------------------
 375:			; FILL ( addr n c -- )
 376:			;-------------------------------
 377:			; Fill 'n' bytes with 'c' value starting from 'addr'
 378:	304C          	fillName:
 379:	304C  46494CCC	    .DC    "FILL"     ; Name Fieldh (DC sets bit 7 of last char)
 380:	3050  3C30    	    .WORD  cmoveLink  ; Link Field: previous defined word in vocabulary
 381:	3052          	fillLink:
 382:	3052  04      	    .BYTE  $ - fillName - 2  ; Name Length Field
 383:	3053  5530    	    .WORD  $ + 2             ; Code Field
 384:			    ;----------
 385:	C18B  DF      		FORTHpop          ; pop E = 'c' (D is irrelevant)
 386:	3056  7B      	    LD    A,E         ; save 'c'
 387:	3057  CD4E08  		CALL  forthPopBC  ; BC = 'n' (byte counter)
 388:	C190  DF      		FORTHpop          ; pop DE = 'addr'
 389:	305B  EB      		EX    DE,HL       ; HL = 'addr'
 390:	305C  5F      		LD    E,A         ; E = 'c'
 391:	305D  CD5732  	    CALL  fill        ; Fill memory block
 392:	C196  FDE9    	    FORTHreturn       ; Return back to FORTH
 393:			
 394:			;-------------------------------
 395:			; DEPTH ( -- n )
 396:			;-------------------------------
 397:			; Data Stack Depth (code from the Jupiter Ace Manual)
 398:			; : DEPTH  15419 @ HERE 12 + - 2 / ;
 399:	3062          	depthName:
 400:	3062  44455054	    .DC    "DEPTH"      ; Name Field: (DC sets bit 7 of last char)
	      C8
 401:	3067  5230    	    .WORD  fillLink     ; Link Field: point to previous word Name Length Field
 402:	3069          	depthLink:
 403:	3069  05      	    .BYTE  $ - depthName - 2  ; Name Length Field
 404:	306A  C30E    	    .WORD  CF_DO_COLON        ; Code Field Address: a FORTH word
 405:			    ;----------
 406:	306C  1110    	    .WORD  F_STK_WORD       ; SPARE system variable
 407:	306E  3B3C    		.WORD  SPARE     
 408:	3070  B308    		.WORD  F_FETCH          ; @
 409:	3072  6004    	    .WORD  F_HERE           ; HERE
 410:	3074  1110    		.WORD  F_STK_WORD       ; 12
 411:	3076  0C00    	    .WORD  12        
 412:	3078  D20D    		.WORD  F_PLUS           ; +
 413:	307A  E10D    		.WORD  F_MINUS          ; -
 414:	307C  1110    		.WORD  F_STK_WORD       ; 2
 415:	307E  0200    		.WORD  2         
 416:	3080  510D    	    .WORD  F_DIV            ; /
 417:	3082  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)	
 418:			
 419:			;-------------------------------
 420:			;***** To Do: FORTH Words to add *****
 421:			;-------------------------------
 422:			; -TRAILING
 423:			; ( from the Ace Manual )
 424:			; : KEY ( -- c )  BEGIN INKEY ?DUP UNTIL ;
 425:			; : ' ( -- n )  FIND 2+ ;
 426:			; : .S ( print data stack contents )
 427:			;   15419 @ HERE 12 +
 428:			;   OVER OVER -
 429:			;   IF  ( if stack not empty )
 430:			;     DO
 431:			;       I @ . 2
 432:			;     +LOOP
 433:			;   ELSE  ( stack is empty)
 434:			;     DROP DROP
 435:			;   THEN
 436:			; ;
 437:			; ( Others )
 438:			; SSAVE ( save dictionary over serial interface )
 439:			; SLOAD ( load dictionary from serial interface )
 440:				
 441:			;-------------------------------
 442:			; HEX ( -- )
 443:			;-------------------------------
 444:			; Change numeric base to Hexadecimal
 445:	3084          	hexName:
 446:	3084  4845D8  	    .DC    "HEX"         ; Name Field: (DC sets bit 7 of last char)
 447:	3087  6930    	    .WORD  depthLink     ; Link Field: point to previous word Name Length Field
 448:	3089          	hexLink:
 449:	3089  03      	    .BYTE  $ - hexName - 2  ; Name Length Field
 450:	308A  C30E    	    .WORD  CF_DO_COLON      ; Code Field Address: a FORTH word
 451:			    ;----------
 452:	308C  4B10    	    .WORD  F_STK_BYTE       ; push following byte to Data Stack
 453:	308E  10      		.BYTE  16
 454:	308F  8A04    	    .WORD  F_BASE           ; BASE
 455:	3091  A508    	    .WORD  F_CSTORE         ; C!
 456:	3093  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 457:				
 458:			;-------------------------------
 459:			; PSG! ( c reg -- )
 460:			;-------------------------------
 461:			; Write 'c' to PSG register 'reg'
 462:	3095          	psgwName:
 463:	3095  505347A1	    .DC    "PSG!"       ; Name Fieldh (DC sets bit 7 of last char)
 464:	3099  8930    	    .WORD  hexLink      ; Link Field: point to previous word Name Length Field
 465:	309B          	psgwLink:
 466:	309B  04      	    .BYTE  $ - psgwName - 2  ; Name Length Field
 467:	309C  9E30    	    .WORD  $ + 2             ; Code Field
 468:			    ;----------
 469:	C1D4  DF      	    FORTHpop         ; Pop DE from FORTH data stack
 470:	309F  7B      	    LD   A,E         ; Use only the lower byte
 471:	30A0  D3FD    	    OUT  (PSG_REG),A ; Select PSG register
 472:			
 473:	C1D8  DF      	    FORTHpop         ; Pop DE from FORTH data stack
 474:	30A3  7B      	    LD   A,E         ; Use only the lower byte
 475:	30A4  D3FF    	    OUT  (PSG_VAL),A ; Set selected PSG register value
 476:	C1DC  FDE9    	    FORTHreturn      ; Return to FORTH
 477:			
 478:			;-------------------------------
 479:			; PSG@ ( reg -- c )
 480:			;-------------------------------
 481:			; Read PSG register 'reg' contents
 482:	30A8          	psgrName:
 483:	30A8  505347C0	    .DC    "PSG@"     ; Name Fieldh (DC sets bit 7 of last char)
 484:	30AC  9B30    	    .WORD  psgwLink   ; Link Field: previous defined word in vocabulary
 485:	30AE          	psgrLink:
 486:	30AE  04      	    .BYTE  $ - psgrName - 2  ; Name Length Field
 487:	30AF  B130    	    .WORD  $ + 2             ; Code Field
 488:			    ;----------
 489:	C1E7  DF      	    FORTHpop         ; Pop DE from FORTH data stack
 490:	30B2  7B      	    LD   A,E         ; Use only the lower byte
 491:	30B3  D3FD    	    OUT  (PSG_REG),A ; Select PSG register
 492:	30B5  DBFF    	    IN   A,(PSG_VAL) ; Read selected PSG register
 493:	30B7  5F      	    LD   E,A         ; Data is a single byte
 494:	30B8  AF      	    XOR  A           ; Clear D
 495:	30B9  57      	    LD   D,A
 496:	C1F0  D7      	    FORTHpush        ; Push DE to FORTH data stack
 497:	C1F1  FDE9    	    FORTHreturn      ; Return to FORTH
 498:			
 499:			;-------------------------------
 500:			; MPAGE ( c -- )
 501:			;-------------------------------
 502:			; Select memory page 'c' , 0 to 3
 503:	30BD          	mpageName:
 504:	30BD  4D504147	    .DC    "MPAGE"    ; Name Fieldh (DC sets bit 7 of last char)
	      C5
 505:	30C2  AE30    	    .WORD  psgrLink   ; Link Field: previous defined word in vocabulary
 506:	30C4          	mpageLink:
 507:	30C4  05      	    .BYTE  $ - mpageName - 2  ; Name Length Field
 508:	30C5  C730    	    .WORD  $ + 2              ; Code Field
 509:			    ;----------
 510:	30C7  3E0F    	    LD    A,PSGportB   ; Select PSG Port B Register
 511:	30C9  D3FD    	    OUT   (PSG_REG),A
 512:	30CB  DBFF    	    IN    A,(PSG_VAL)  ; Read PSG Port B
 513:	30CD  E6FC    	    AND   11111100b    ; mask out mem page bits
 514:	30CF  4F      	    LD    C,A          ; save BORDER color, screen page and char set
 515:			    
 516:	C206  DF      	    FORTHpop           ; Pop DE from FORTH data stack
 517:	30D1  7B      	    LD    A,E          ; memory page
 518:	30D2  E603    	    AND   00000011b    ; limit memory paging to 0..3
 519:	30D4  B1      	    OR    C            ; combine with saved BORDER color, screen page and char set
 520:	30D5  D3FF    	    OUT   (PSG_VAL),A  ; Write to PSG Port B
 521:	C20D  FDE9    	    FORTHreturn        ; Return to FORTH
 522:			
 523:			;-------------------------------
 524:			; SCREEN ( c --  )
 525:			;-------------------------------
 526:			; Select Screen page 'c' , 0 or 1
 527:	30D9          	screenName:
 528:	30D9  53435245	    .DC    "SCREEN"   ; Name Fieldh (DC sets bit 7 of last char)
	      45CE
 529:	30DF  C430    	    .WORD  mpageLink  ; Link Field: previous defined word in vocabulary
 530:	30E1          	screenLink:
 531:	30E1  06      	    .BYTE  $ - screenName - 2  ; Name Length Field
 532:	30E2  E430    	    .WORD  $ + 2               ; Code Field
 533:			    ;----------
 534:	30E4  3E0F    	    LD   A,PSGportB   ; Select PSG Port B Register
 535:	30E6  D3FD    	    OUT  (PSG_REG),A
 536:	30E8  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port B value
 537:	30EA  E6FB    	    AND  11111011b    ; mask out Screen page bit 
 538:	30EC  4F      	    LD   C,A          ; save BORDER color, memory and char set paging
 539:			    
 540:	C223  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 541:	30EE  7B      	    LD   A,E          ; screen page
 542:	30EF  E601    	    AND  00000001b    ; limit Screen page to 0 or 1
 543:	30F1  CB27    	    SLA  A            ; move to bit-2 position
 544:	30F3  CB27    	    SLA  A
 545:	30F5  B1      	    OR   C            ; combine with saved BORDER color, memory page and char set
 546:	30F6  D3FF    	    OUT  (PSG_VAL),A  ; Write to PSG Port B
 547:	C22E  FDE9    	    FORTHreturn       ; Return to FORTH
 548:			
 549:			;-------------------------------
 550:			; FONT ( c --  )
 551:			;-------------------------------
 552:			; Select character set 'c' , 0 or 1
 553:	30FA          	fontName:
 554:	30FA  464F4ED4	    .DC    "FONT"     ; Name Fieldh (DC sets bit 7 of last char)
 555:	30FE  E130    	    .WORD  screenLink ; Link Field: previous defined word in vocabulary
 556:	3100          	fontLink:
 557:	3100  04      	    .BYTE  $ - fontName - 2  ; Name Length Field
 558:	3101  0331    	    .WORD  $ + 2             ; Code Field
 559:			    ;----------
 560:	3103  3E0F    	    LD   A,PSGportB   ; Select PSG Port B Register
 561:	3105  D3FD    	    OUT  (PSG_REG),A
 562:	3107  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port B value
 563:	3109  E6F7    	    AND  11110111b    ; mask out char set bit 
 564:	310B  4F      	    LD   C,A          ; save BORDER color, memory and screen pages
 565:			    
 566:	C242  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 567:	310D  7B      	    LD   A,E          ; character set
 568:	310E  E601    	    AND  00000001b    ; limit Character Set paging to 0 or 1
 569:	3110  CB27    	    SLA  A            ; move to bit-3 position
 570:	3112  CB27    	    SLA  A
 571:	3114  CB27    	    SLA  A
 572:	3116  B1      	    OR   C            ; combine with saved BORDER color, memory and screen pages
 573:	3117  D3FF    	    OUT  (PSG_VAL),A  ; Write to PSG Port B
 574:	C24F  FDE9    	    FORTHreturn       ; Return to FORTH
 575:			
 576:			;-------------------------------
 577:			; BAUD ( n --  )
 578:			;-------------------------------
 579:			; Set UART to Baud rate 'n'
 580:	311B          	baudName:
 581:	311B  424155C4	    .DC    "BAUD"    ; Name Fieldh (DC sets bit 7 of last char)
 582:	311F  0031    	    .WORD  fontLink  ; Link Field: previous defined word in vocabulary
 583:	3121          	baudLink:
 584:	3121  04      	    .BYTE  $ - baudName - 2  ; Name Length Field
 585:	3122  C30E    	    .WORD  CF_DO_COLON       ; Code Field
 586:			    ;----------
 587:	3124  4B10    		.WORD  F_STK_BYTE   ; 10
 588:	3126  0A      		.BYTE  10
 589:	3127  510D    		.WORD  F_DIV        ; /
 590:	3129  1110    		.WORD  F_STK_WORD   ; 23040
 591:	312B  005A    	    .WORD  23040
 592:	312D  8508    	    .WORD  F_SWAP       ; SWAP	
 593:	312F  510D    	    .WORD  F_DIV        ; /  (result is baud divider)
 594:	3131  0E1A    		.WORD  DOCODE       ; execute following Asm code
 595:	3133  CD4E08  		CALL   forthPopBC   ; BC = UART Baud rate divisor
 596:	3136  CD7A32  		CALL   UartSet      ; UART setup
 597:	C26F  FDE9    	    FORTHreturn         ; Return back to FORTH
 598:			
 599:			;-------------------------------
 600:			; TX ( addr n --  )
 601:			;-------------------------------
 602:			; Transmit 'n' bytes from 'addr' to serial line
 603:	313B          	txName:
 604:	313B  54D8    	    .DC    "TX"      ; Name Fieldh (DC sets bit 7 of last char)
 605:	313D  2131    	    .WORD  baudLink  ; Link Field: previous defined word in vocabulary
 606:	313F          	txLink:
 607:	313F  02      	    .BYTE  $ - txName - 2  ; Name Length Field
 608:	3140  4231    	    .WORD  $ + 2           ; Code Field
 609:			    ;----------
 610:	3142  CD4E08  		CALL   forthPopBC      ; pop BC = 'n' from Data Stack
 611:	C27B  DF      		FORTHpop               ; pop DE = 'addr' from data stack
 612:	3146  EB      		EX     DE,HL           ; HL = 'addr' = Starting address
 613:	3147  50      		LD     D,B             ; DE = 'n'    = Number of bytes to transmit
 614:	3148  59      		LD     E,C
 615:	3149  CDC732  		CALL   UartTx          ; Transmit Serial Data Block
 616:	C282  FDE9    	    FORTHreturn            ; Return back to FORTH
 617:			
 618:			;-------------------------------
 619:			; RX ( addr n --  )
 620:			;-------------------------------
 621:			; Receive 'n' bytes from serial line to 'addr'
 622:	314E          	rxName:
 623:	314E  52D8    	    .DC    "RX"    ; Name Fieldh (DC sets bit 7 of last char)
 624:	3150  3F31    	    .WORD  txLink  ; Link Field: previous defined word in vocabulary
 625:	3152          	rxLink:
 626:	3152  02      	    .BYTE  $ - rxName - 2  ; Name Length Field
 627:	3153  5531    	    .WORD  $ + 2           ; Code Field
 628:			    ;----------
 629:	3155  CD4E08  		CALL   forthPopBC      ; pop BC = 'n' from Data Stack
 630:	C28E  DF      	    FORTHpop               ; pop DE = 'addr' from Data Stack
 631:	3159  EB      		EX     DE,HL           ; HL = 'addr' = Starting address
 632:	315A  50      		LD     D,B             ; DE = 'n'    = Number of bytes to receive
 633:	315B  59      		LD     E,C
 634:	315C  CD9C32  		CALL   UartRx          ; Receive Serial Data Block
 635:	C295  FDE9    	    FORTHreturn            ; Return back to FORTH
 636:				
 637:			;-------------------------------
 638:			; BORDER ( c --  )
 639:			;-------------------------------
 640:			; Set screen BORDER to color 'c' , 0 to 15
 641:	3161          	borderName:
 642:	3161  424F5244	    .DC    "BORDER"  ; Name Fieldh (DC sets bit 7 of last char)
	      45D2
 643:	3167  5231    	    .WORD  rxLink    ; Link Field: previous defined word in vocabulary
 644:	3169          	borderLink:
 645:	3169  06      	    .BYTE  $ - borderName - 2  ; Name Length Field
 646:	316A  6C31    	    .WORD  $ + 2               ; Code Field
 647:			    ;----------
 648:	316C  3E0F    	    LD   A,PSGportB   ; Select PSG Port B Register
 649:	316E  D3FD    	    OUT  (PSG_REG),A
 650:	3170  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port B value
 651:	3172  E60F    	    AND  00001111b    ; mask out BORDER color
 652:	3174  4F      	    LD   C,A          ; save memory and screen pages and char set
 653:	C2AB  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 654:	3176  7B      	    LD   A,E          ; A = BORDER color
 655:	3177  CB27    	    SLA  A            ; position BORDER color at the higher 4 bits
 656:	3179  CB27    	    SLA  A            ; (also limiting BORDER color to 0..15)
 657:	317B  CB27    	    SLA  A
 658:	317D  CB27    	    SLA  A
 659:	317F  B1      	    OR   C            ; combine with saved memory and screen pages and char set
 660:	3180  D3FF    	    OUT  (PSG_VAL),A  ; Write back to Port A
 661:	C2B8  FDE9    	    FORTHreturn       ; Return back to FORTH
 662:				
 663:			;-------------------------------
 664:			; INK ( c -- )
 665:			;-------------------------------
 666:			; Set character INK (foreground) to color 'c' , 0 to 15
 667:	3184          	inkName:
 668:	3184  494ECB  	    .DC    "INK"       ; Name Fieldh (DC sets bit 7 of last char)
 669:	3187  6931    	    .WORD  borderLink  ; Link Field: previous defined word in vocabulary
 670:	3189          	inkLink:
 671:	3189  03      	    .BYTE  $ - inkName - 2  ; Name Length Field
 672:	318A  8C31    	    .WORD  $ + 2            ; Code Field
 673:			    ;----------
 674:	318C  3E0E    	    LD   A,PSGportA   ; Select PSG Port A Register
 675:	318E  D3FD    	    OUT  (PSG_REG),A
 676:	3190  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port A value
 677:	3192  E6F0    	    AND  11110000b    ; mask out current INK color
 678:	3194  4F      	    LD   C,A          ; save PAPER color
 679:	C2CB  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 680:	3196  7B      	    LD   A,E          ; A = INK color
 681:	3197  E60F    	    AND  00001111b    ; limit INK color to 0..15
 682:	3199  B1      	    OR   C            ; combine with saved PAPER color
 683:	319A  D3FF    	    OUT  (PSG_VAL),A  ; Write back to Port A
 684:	C2D2  FDE9    	    FORTHreturn       ; Return back to FORTH
 685:			
 686:			;-------------------------------
 687:			; PAPER ( c -- )
 688:			;-------------------------------
 689:			; Set character PAPER (background) color to 'c' , 0 to 15
 690:	319E          	paperName:
 691:	319E  50415045	    .DC    "PAPER"    ; Name Fieldh (DC sets bit 7 of last char)
	      D2
 692:	31A3  8931    	    .WORD  inkLink    ; Link Field: previous defined word in vocabulary
 693:	31A5          	paperLink:
 694:	31A5  05      	    .BYTE  $ - paperName - 2  ; Name Length Field
 695:	31A6  A831    	    .WORD  $ + 2              ; Code Field
 696:			    ;----------
 697:	31A8  3E0E    	    LD   A,PSGportA   ; Select PSG Port A Register
 698:	31AA  D3FD    	    OUT  (PSG_REG),A
 699:	31AC  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port A value
 700:	31AE  E60F    	    AND  00001111b    ; mask out current PAPER color, preserving INK color
 701:	31B0  4F      	    LD   C,A          ; save INK color
 702:	C2E7  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 703:	31B2  7B      	    LD   A,E          ; A = PAPER color
 704:	31B3  CB27    	    SLA  A            ; position PAPER color at the higher 4 bits
 705:	31B5  CB27    	    SLA  A            ; (also limits PAPER color to 0..15)
 706:	31B7  CB27    	    SLA  A
 707:	31B9  CB27    	    SLA  A
 708:	31BB  B1      	    OR   C            ; combine with saved INK color
 709:	31BC  D3FF    	    OUT  (PSG_VAL),A  ; Write back to Port A
 710:	C2F4  FDE9    	    FORTHreturn       ; Return back to FORTH
 711:			
 712:			;-------------------------------
 713:			; BLACK ( -- c )
 714:			;-------------------------------
 715:	31C0          	blackName:
 716:	31C0  424C4143	    .DC    "BLACK"    ; Name Fieldh (DC sets bit 7 of last char)
	      CB
 717:	31C5  A531    	    .WORD  paperLink  ; Link Field: previous defined word in vocabulary
 718:	31C7          	blackLink:
 719:	31C7  05      	    .BYTE  $ - blackName - 2  ; Name Length Field
 720:	31C8  CA31    	    .WORD  $ + 2              ; Code Field
 721:			    ;----------
 722:	31CA  1E00    		LD    E,0                 ; Black color
 723:	31CC          	stackByteAndFinish:
 724:	31CC  1600    	    LD    D,0                 ; Clear High byte
 725:	C304  D7      		FORTHpush                 ; Push DE to FORTH data stack
 726:	C305  FDE9    	    FORTHreturn               ; Return back to FORTH
 727:			
 728:			;-------------------------------
 729:			; GREY ( -- c )
 730:			;-------------------------------
 731:			; 8 CONSTANT
 732:	31D1          	greyName:
 733:	31D1  475245D9	    .DC    "GREY"     ; Name Fieldh (DC sets bit 7 of last char)
 734:	31D5  C731    	    .WORD  blackLink  ; Link Field: previous defined word in vocabulary
 735:	31D7          	greyLink:
 736:	31D7  04      	    .BYTE  $ - greyName - 2  ; Name Length Field
 737:	31D8  DA31    	    .WORD  $ + 2             ; Code Field
 738:			    ;----------
 739:	31DA  1E08    	    LD    E,1000b            ; Grey color
 740:	31DC  C3CC31  		JP    stackByteAndFinish
 741:			
 742:			;-------------------------------
 743:			; BLUE ( -- c )
 744:			;-------------------------------
 745:	31DF          	blueName:
 746:	31DF  424C55C5	    .DC    "BLUE"     ; Name Fieldh (DC sets bit 7 of last char))
 747:	31E3  D731    	    .WORD  greyLink   ; Link Field: previous defined word in vocabulary
 748:	31E5          	blueLink:
 749:	31E5  04      	    .BYTE  $ - blueName - 2  ; Name Length Field
 750:	31E6  E831    	    .WORD  $ + 2             ; Code Field
 751:			    ;----------
 752:	31E8  1E09    	    LD    E,1001b            ; Blue color
 753:	31EA  C3CC31  		JP    stackByteAndFinish
 754:			
 755:			;-------------------------------
 756:			; GREEN ( -- c )
 757:			;-------------------------------
 758:	31ED          	greenName:
 759:	31ED  47524545	    .DC    "GREEN"    ; Name Fieldh (DC sets bit 7 of last char)
	      CE
 760:	31F2  E531    	    .WORD  blueLink   ; Link Field: previous defined word in vocabulary
 761:	31F4          	greenLink:
 762:	31F4  05      	    .BYTE  $ - greenName - 2  ; Name Length Field
 763:	31F5  F731    	    .WORD  $ + 2              ; Code Field
 764:			    ;----------
 765:	31F7  1E0A    	    LD    E,1010b             ; Green color
 766:	31F9  C3CC31  		JP    stackByteAndFinish
 767:			
 768:			;-------------------------------
 769:			; CYAN ( -- c )
 770:			;-------------------------------
 771:	31FC          	cyanName:
 772:	31FC  435941CE	    .DC    "CYAN"     ; Name Fieldh (DC sets bit 7 of last char)
 773:	3200  F431    	    .WORD  greenLink  ; Link Field: previous defined word in vocabulary
 774:	3202          	cyanLink:
 775:	3202  04      	    .BYTE  $ - cyanName - 2  ; Name Length Field
 776:	3203  0532    	    .WORD  $ + 2             ; Code Field
 777:			    ;----------
 778:	3205  1E0B    	    LD    E,1011b            ; Cyan color
 779:	3207  C3CC31  		JP    stackByteAndFinish
 780:			
 781:			;-------------------------------
 782:			; RED ( -- c )
 783:			;-------------------------------
 784:	320A          	redName:
 785:	320A  5245C4  	    .DC    "RED"      ; Name Fieldh (DC sets bit 7 of last char)
 786:	320D  0232    	    .WORD  cyanLink   ; Link Field: previous defined word in vocabulary
 787:	320F          	redLink:
 788:	320F  03      	    .BYTE  $ - redName - 2  ; Name Length Field
 789:	3210  1232    	    .WORD  $ + 2            ; Code Field
 790:			    ;----------
 791:	3212  1E0C    	    LD    E,1100b           ; Red color
 792:	3214  C3CC31  		JP    stackByteAndFinish
 793:			
 794:			;-------------------------------
 795:			; PURPLE ( -- c )
 796:			;-------------------------------
 797:	3217          	purpleName:
 798:	3217  50555250	    .DC    "PURPLE"  ; Name Fieldh (DC sets bit 7 of last char)
	      4CC5
 799:	321D  0F32    	    .WORD  redLink   ; Link Field: previous defined word in vocabulary
 800:	321F          	purpleLink:
 801:	321F  06      	    .BYTE  $ - purpleName - 2  ; Name Length Field
 802:	3220  2232    	    .WORD  $ + 2               ; Code Field
 803:			    ;----------
 804:	3222  1E0D    	    LD    E,1101b              ; Purple color
 805:	3224  C3CC31  		JP    stackByteAndFinish
 806:			
 807:			;-------------------------------
 808:			; YELLOW ( -- c )
 809:			;-------------------------------
 810:	3227          	yellowName:
 811:	3227  59454C4C	    .DC    "YELLOW"    ; Name Fieldh (DC sets bit 7 of last char)
	      4FD7
 812:	322D  1F32    	    .WORD  purpleLink  ; Link Field: previous defined word in vocabulary
 813:	322F          	yellowLink:
 814:	322F  06      	    .BYTE  $ - yellowName - 2  ; Name Length Field
 815:	3230  3232    	    .WORD  $ + 2               ; Code Field
 816:			    ;----------
 817:	3232  1E0E    	    LD    E,1110b              ; Yellow color
 818:	3234  C3CC31  		JP    stackByteAndFinish
 819:			
 820:			;-------------------------------
 821:			; WHITE ( -- c )
 822:			;-------------------------------
 823:	3237          	whiteName:
 824:	3237  57484954	    .DC    "WHITE"     ; Name Fieldh (DC sets bit 7 of last char)
	      C5
 825:	323C  2F32    	    .WORD  yellowLink  ; Link Field: previous defined word in vocabulary
 826:	323E          	whiteLink:
 827:	323E  05      	    .BYTE  $ - whiteName - 2  ; Name Length Field
 828:	323F  4132    	    .WORD  $ + 2              ; Code Field
 829:			    ;----------
 830:	3241  1E0F    	    LD    E,1111b             ; White color
 831:	3243  C3CC31  		JP    stackByteAndFinish
 832:			
 833:			;-------------------------------
 834:			; DARK ( c1 -- c2 )
 835:			;-------------------------------
 836:			; Change color code on stack to darker tone
 837:	3246          	darkName:
 838:	3246  444152CB	    .DC    "DARK"     ; Name Fieldh (DC sets bit 7 of last char)
 839:	324A  3E32    	    .WORD  whiteLink  ; Link Field: previous defined word in vocabulary
 840:	324C          	darkLink:
 841:	324C  04      	    .BYTE  $ - darkName - 2  ; Name Length Field
 842:	324D  4F32    	    .WORD  $ + 2             ; Code Field
 843:			    ;----------
 844:	C385  DF      	    FORTHpop                 ; Pop from FORTH data stack to DE
 845:	3250  7B      	    LD    A,E                ; Get lower byte
 846:	3251  E607    	    AND   0111b              ; Clear intensity bit3
 847:	3253  5F      	    LD    E,A                ; Put it back in Data Stack
 848:	3254  C3CC31  	    JP    stackByteAndFinish
 849:			
 850:			;------------------------------------------------------------------------------
 851:			; XDICT Subroutines -----------------------------------------------------------
 852:			;------------------------------------------------------------------------------
 853:			
 854:			;-------------------------------
 855:			; Fill memory block
 856:			; Input: HL = Starting address to fill
 857:			;        BC = Number of bytes to fill
 858:			;        E  = Filling byte value
 859:	3257          	fill:
 860:	3257  78      	    LD    A,B         ; Check if block size is zero
 861:	3258  B1      	    OR    C
 862:	3259  C8      		RET   Z           ; If block size = 0 , Exit loop
 863:				;----
 864:	325A  73      	    LD    (HL),E      ; write one byte
 865:	325B  23      	    INC   HL          ; move to next address
 866:	325C  0B      		DEC   BC          ; Number of bytes Countdown
 867:	325D  18F8    		JR    fill        ; Fill loop
 868:			
 869:			;-------------------------------
 870:			; Block move code based on 'Z80 Assembly Language Routines' from 'Lance A. Leventhal'
 871:			; Input: HL = Source address
 872:			;        DE = Destination address
 873:			;        BC = Number of bytes to move
 874:			; Affects: AF, BC, DE, HL
 875:	325F          	cmove:
 876:	325F  78      	    LD    A,B    ; check if zero bytes to move
 877:	3260  B1      		OR    C
 878:	3261  C8      		RET   Z      ; if zero bytes to move , Abort
 879:				; check for overlaping regions
 880:	3262  EB      	    EX    DE,HL   ; calculate destination - source
 881:	3263  E5      		PUSH  HL      ; save destination address
 882:	3264  A7      		AND   A       ; prepare for subtraction (clear carry)
 883:	3265  ED52    		SBC   HL,DE   ; HL = destination - source
 884:	3267  A7      		AND   A       ; prepare for subtraction (clear carry)
 885:	3268  ED42    		SBC   HL,BC   ; subtract size
 886:	326A  E1      		POP   HL      ; restore destination address
 887:	326B  EB      		EX    DE,HL   ; HL = source , DE = destinattion
 888:	326C  3009    		JR    NC,cmoveUp ; no overlaping , move up
 889:				; Destination area is above and overlaps with source
 890:				; move from highest address avoiding data destruction
 891:	326E  09      		ADD   HL,BC     ; sourceHigh = sourceLow + length - 1
 892:	326F  2B      		DEC   HL
 893:	3270  EB      		EX    DE,HL
 894:	3271  09      		ADD   HL,BC     ; destHigh = destLo + length - 1
 895:	3272  2B      		DEC   HL
 896:	3273  EB      		EX    DE,HL     ; HL = source , DE = destination
 897:	3274  EDB8    		LDDR            ; Block move high to low
 898:	3276  C9      		RET
 899:	3277          	cmoveUp:
 900:	3277  EDB0    	    LDIR            ; Block move low to high
 901:	3279  C9      		RET
 902:			
 903:			;------------------------------- (UART 16C450)
 904:			; UART Inititalization: 8 data bits, 1 stop bit, no parity
 905:			;   Input: BC = Baud rate divisor
 906:			; Affects: A
 907:			; Baud rate divisor = 3,686,400 / (16 * baud rate)
 908:			;    Baud: 300 | 1200 | 2400 | 3600 | 4800 | 9600 | 19200
 909:			; Divisor: 768 |  192 |   96 |   64 |   48 |   24 |    12
 910:	327A          	UartSet:                 
 911:	327A  3E80    	    LD    A,$80        ; Set DLAB flag
 912:	327C  D3E7    	    OUT   (UART_LCR),A
 913:	327E  79      	    LD    A,C          ; Set Baud Rate divisor (Less Significant Byte)
 914:	327F  D3E1    	    OUT   (UART_DLL),A
 915:	3281  78      	    LD    A,B          ; Set Baud Rate divisor (Most Significant Byte)
 916:	3282  D3E3    	    OUT   (UART_DLM),A 
 917:	3284  3E03    	    LD    A,$03        ; 8-bit data, 1 stop-bit, no parity, reset DLAB flag
 918:	3286  D3E7    	    OUT   (UART_LCR),A
 919:	3288  C9      	    RET
 920:			
 921:			;------------------------------- (UART 16C450)
 922:			; Check if UART exist by writing/reading scratch register
 923:			; Output: A=0 and Z flag set only if UART exists
 924:			; Affects: A 
 925:	3289          	UartCheck:
 926:	3289  3EAA    		LD    A,$AA             ; Test pattern 1
 927:	328B  D3EF    		OUT   (UART_SCR),A      ; Write test bits to Scratch register
 928:	328D  DBEF    		IN    A,(UART_SCR)      ; Read it back
 929:	328F  EEAA    		XOR   $AA               ; If success, A=0 and Z flag is set
 930:	3291  2008    		JR    NZ,UartCheckExit  ; Fail, get out
 931:				;----
 932:	3293  3E55    		LD    A,$55             ; Test pattern 2
 933:	3295  D3EF    		OUT   (UART_SCR),A      ; Write test bits to Scratch register
 934:	3297  DBEF    		IN    A,(UART_SCR)      ; Read it back
 935:	3299  EE55    		XOR   $55               ; If success, A=0 and Z flag is set	
 936:	329B          	UartCheckExit:
 937:	329B  C9      		RET
 938:				
 939:			;------------------------------- (UART 16C450)
 940:			; Receive bytes from serial line
 941:			; Input: HL = destination memory block
 942:			;        DE = bytes to receive
 943:	329C          	UartRx:
 944:	329C  CD8932  		CALL  UartCheck      ; Check if UART exist
 945:	329F  C0      		RET   NZ             ; UART does not exist, abort
 946:	32A0          	UartRxWait:
 947:	32A0  01FE7F  	    LD   BC,$7FFE        ; Check for Break Key (space scan group)
 948:	32A3  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 949:	32A5  CB47    		BIT  0,A             ; Check for 'space' keypress
 950:	32A7  28F7    		JR   Z,UartRxWait    ; 'space' key pressed , wait release
 951:				;----
 952:	32A9  F3      		DI                   ; Avoid interrupts
 953:	32AA          	UartRxLoop:
 954:			    ; Check for Break Key (relies on LD BC,$7FFE above)
 955:	32AA  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 956:	32AC  CB47    		BIT  0,A             ; Check for 'space' keypress
 957:	32AE  280F    		JR   Z,UartExit      ; 'space' key pressed , Abort
 958:			    ; Check if new byte arrived
 959:	32B0  DBEB    	    IN    A,(UART_LSR)   ; Read Line Status Register
 960:	32B2  CB47    	    BIT   0,A            ; check UART ready to receive flag
 961:	32B4  28F4    	    JR    Z,UartRxLoop   ; wait if not ready
 962:			    ; Get received byte
 963:	32B6  DBE1    	    IN    A,(UART_DATA)  ; Get received byte
 964:	32B8  77      		LD    (HL),A         ; Store it in memory
 965:	32B9  23      		INC   HL             ; Point to next receive memory position
 966:	32BA  1B      		DEC   DE             ; Countdown received bytes
 967:	32BB  7A      		LD    A,D            ; Last byte ?
 968:	32BC  B3      		OR    E
 969:	32BD  20EB    		JR    NZ,UartRxLoop  ; No, Receive next byte
 970:	32BF          	UartExit:
 971:	32BF  CD3603  	    CALL  scanKbrd       ; Wait for key release
 972:	32C2  A7      	    AND   A
 973:	32C3  20FA    		JR    NZ,UartExit
 974:			
 975:	32C5  FB      	    EI                   ; Re-enable Interrupts
 976:	32C6  C9      	    RET
 977:			
 978:			;------------------------------- (UART 16C450)
 979:			; Transmit bytes over serial line
 980:			; Input: HL = source memory block
 981:			;        DE = bytes to transmit
 982:	32C7          	UartTx:
 983:	32C7  CD8932  		CALL  UartCheck      ; Check if UART exist
 984:	32CA  C0      		RET   NZ             ; UART does not exist, abort
 985:	32CB          	UartTxWait:
 986:	32CB  01FE7F  	    LD   BC,$7FFE        ; Check for Break Key
 987:	32CE  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 988:	32D0  CB47    		BIT  0,A             ; Check for 'space' keypress
 989:	32D2  28F7    		JR   Z,UartTxWait    ; 'space' key pressed , wait release	
 990:			    ;----
 991:	32D4  F3      		DI                   ; Avoid Interrupts
 992:	32D5          	UartTxLoop:
 993:			    ; Check for Break Key (relies on LD BC,$7FFE above)
 994:	32D5  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 995:	32D7  CB47    		BIT  0,A             ; Check for 'space' keypress
 996:	32D9  28E4    		JR   Z,UartExit      ; 'space' key pressed , Abort
 997:			    ; Check if last byte was transmitted
 998:	32DB  DBEB    	    IN   A,(UART_LSR)    ; Read Line Status Register
 999:	32DD  CB6F    		BIT  5,A             ; check UART ready to send flag
1000:	32DF  28F4    		JR   Z,UartTxLoop    ; wait if not ready
1001:			    ; Send a new byte
1002:	32E1  7E      	    LD    A,(HL)         ; Get byte to transmit	
1003:	32E2  D3E1    	    OUT   (UART_DATA),A  ; Send byte
1004:	32E4  23      	    INC   HL             ; Point to next data byte
1005:	32E5  1B      		DEC   DE             ; Countdown bytes transmitted
1006:	32E6  7A      		LD    A,D            ; Last byte ?
1007:	32E7  B3      		OR    E
1008:	32E8  20EB    		JR    NZ,UartTxLoop  ; No, Transmit next byte
1009:				;----
1010:	32EA  C3BF32  		JP    UartExit       ; Exit
1011:			
1012:			;##############################################################################
1013:	C423          	    .DEPHASE
1014:			;##############################################################################
1015:	C423          	dictExpEnd:
1016:			
1017:			;==============================================================================
1018:			; Alternate Character Set =====================================================
1019:			;==============================================================================
1020:	C423          	charSet:
1021:	C423  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	      00000000
1022:	C42B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	      00000000
1023:	C433  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	      00000000
1024:	C43B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	      00000000
1025:	C443  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	      0F0F0F0F
1026:	C44B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	      0F0F0F0F
1027:	C453  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	      0F0F0F0F
1028:	C45B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	      0F0F0F0F
1029:	C463  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	      00000000
1030:	C46B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	      00000000
1031:	C473  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	      00000000
1032:	C47B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	      00000000
1033:	C483  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	      0F0F0F0F
1034:	C48B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	      0F0F0F0F
1035:	C493  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	      0F0F0F0F
1036:	C49B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	      0F0F0F0F
1037:			    
1038:	C4A3  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	      00000000
1039:	C4AB  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	      00000000
1040:	C4B3  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	      00000000
1041:	C4BB  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	      00000000
1042:	C4C3  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	      0F0F0F0F
1043:	C4CB  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	      0F0F0F0F
1044:	C4D3  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	      0F0F0F0F
1045:	C4DB  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	      0F0F0F0F
1046:	C4E3  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	      00000000
1047:	C4EB  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	      00000000
1048:	C4F3  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	      00000000
1049:	C4FB  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	      00000000
1050:	C503  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	      0F0F0F0F
1051:	C50B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	      0F0F0F0F
1052:	C513  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	      0F0F0F0F
1053:	C51B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	      0F0F0F0F
1054:			    
1055:	C523  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; space
	      00000000
1056:	C52B  183C3C18	    .BYTE   018h, 03Ch, 03Ch, 018h, 018h, 000h, 018h, 000h  ; !
	      18001800
1057:	C533  36363600	    .BYTE   036h, 036h, 036h, 000h, 000h, 000h, 000h, 000h  ; "
	      00000000
1058:	C53B  36367F36	    .BYTE   036h, 036h, 07Fh, 036h, 07Fh, 036h, 036h, 000h  ; #
	      7F363600
1059:	C543  183E603C	    .BYTE   018h, 03Eh, 060h, 03Ch, 006h, 07Ch, 018h, 000h  ; $
	      067C1800
1060:	C54B  0063660C	    .BYTE   000h, 063h, 066h, 00Ch, 018h, 033h, 063h, 000h  ; %
	      18336300
1061:	C553  1C361C3B	    .BYTE   01Ch, 036h, 01Ch, 03Bh, 06Eh, 066h, 03Bh, 000h  ; &
	      6E663B00
1062:	C55B  18183000	    .BYTE   018h, 018h, 030h, 000h, 000h, 000h, 000h, 000h  ; '
	      00000000
1063:	C563  0C183030	    .BYTE   00Ch, 018h, 030h, 030h, 030h, 018h, 00Ch, 000h  ; (
	      30180C00
1064:	C56B  30180C0C	    .BYTE   030h, 018h, 00Ch, 00Ch, 00Ch, 018h, 030h, 000h  ; )
	      0C183000
1065:	C573  00663CFF	    .BYTE   000h, 066h, 03Ch, 0FFh, 03Ch, 066h, 000h, 000h  ; *
	      3C660000
1066:	C57B  0018187E	    .BYTE   000h, 018h, 018h, 07Eh, 018h, 018h, 000h, 000h  ; +
	      18180000
1067:	C583  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 018h, 018h, 030h  ; ,
	      00181830
1068:	C58B  0000007E	    .BYTE   000h, 000h, 000h, 07Eh, 000h, 000h, 000h, 000h  ; -
	      00000000
1069:	C593  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 018h, 018h, 000h  ; .
	      00181800
1070:	C59B  060C1830	    .BYTE   006h, 00Ch, 018h, 030h, 060h, 0C0h, 080h, 000h  ; /
	      60C08000
1071:			    
1072:	C5A3  3E63676F	    .BYTE   03Eh, 063h, 067h, 06Fh, 07Bh, 073h, 03Eh, 000h  ; 0
	      7B733E00
1073:	C5AB  18381818	    .BYTE   018h, 038h, 018h, 018h, 018h, 018h, 07Eh, 000h  ; 1
	      18187E00
1074:	C5B3  3C66061C	    .BYTE   03Ch, 066h, 006h, 01Ch, 030h, 066h, 07Eh, 000h  ; 2
	      30667E00
1075:	C5BB  3C66061C	    .BYTE   03Ch, 066h, 006h, 01Ch, 006h, 066h, 03Ch, 000h  ; 3
	      06663C00
1076:	C5C3  0E1E3666	    .BYTE   00Eh, 01Eh, 036h, 066h, 07Fh, 006h, 00Fh, 000h  ; 4
	      7F060F00
1077:	C5CB  7E607C06	    .BYTE   07Eh, 060h, 07Ch, 006h, 006h, 066h, 03Ch, 000h  ; 5
	      06663C00
1078:	C5D3  1C30607C	    .BYTE   01Ch, 030h, 060h, 07Ch, 066h, 066h, 03Ch, 000h  ; 6
	      66663C00
1079:	C5DB  7E66060C	    .BYTE   07Eh, 066h, 006h, 00Ch, 018h, 018h, 018h, 000h  ; 7
	      18181800
1080:	C5E3  3C66663C	    .BYTE   03Ch, 066h, 066h, 03Ch, 066h, 066h, 03Ch, 000h  ; 8
	      66663C00
1081:	C5EB  3C66663E	    .BYTE   03Ch, 066h, 066h, 03Eh, 006h, 00Ch, 038h, 000h  ; 9
	      060C3800
1082:	C5F3  00181800	    .BYTE   000h, 018h, 018h, 000h, 000h, 018h, 018h, 000h  ; :
	      00181800
1083:	C5FB  00181800	    .BYTE   000h, 018h, 018h, 000h, 000h, 018h, 018h, 030h  ; ;
	      00181830
1084:	C603  0C183060	    .BYTE   00Ch, 018h, 030h, 060h, 030h, 018h, 00Ch, 000h  ; <
	      30180C00
1085:	C60B  00007E00	    .BYTE   000h, 000h, 07Eh, 000h, 07Eh, 000h, 000h, 000h  ; =
	      7E000000
1086:	C613  30180C06	    .BYTE   030h, 018h, 00Ch, 006h, 00Ch, 018h, 030h, 000h  ; >
	      0C183000
1087:	C61B  3C66060C	    .BYTE   03Ch, 066h, 006h, 00Ch, 018h, 000h, 018h, 000h  ; ?
	      18001800
1088:			    
1089:	C623  3E636F6F	    .BYTE   03Eh, 063h, 06Fh, 06Fh, 06Fh, 060h, 03Ch, 000h  ; @
	      6F603C00
1090:	C62B  183C6666	    .BYTE   018h, 03Ch, 066h, 066h, 07Eh, 066h, 066h, 000h  ; A
	      7E666600
1091:	C633  7E33333E	    .BYTE   07Eh, 033h, 033h, 03Eh, 033h, 033h, 07Eh, 000h  ; B
	      33337E00
1092:	C63B  1E336060	    .BYTE   01Eh, 033h, 060h, 060h, 060h, 033h, 01Eh, 000h  ; C
	      60331E00
1093:	C643  7C363333	    .BYTE   07Ch, 036h, 033h, 033h, 033h, 036h, 07Ch, 000h  ; D
	      33367C00
1094:	C64B  7F31343C	    .BYTE   07Fh, 031h, 034h, 03Ch, 034h, 031h, 07Fh, 000h  ; E
	      34317F00
1095:	C653  7F31343C	    .BYTE   07Fh, 031h, 034h, 03Ch, 034h, 030h, 078h, 000h  ; F
	      34307800
1096:	C65B  1E336060	    .BYTE   01Eh, 033h, 060h, 060h, 067h, 033h, 01Fh, 000h  ; G
	      67331F00
1097:	C663  6666667E	    .BYTE   066h, 066h, 066h, 07Eh, 066h, 066h, 066h, 000h  ; H
	      66666600
1098:	C66B  3C181818	    .BYTE   03Ch, 018h, 018h, 018h, 018h, 018h, 03Ch, 000h  ; I
	      18183C00
1099:	C673  0F060606	    .BYTE   00Fh, 006h, 006h, 006h, 066h, 066h, 03Ch, 000h  ; J
	      66663C00
1100:	C67B  7333363C	    .BYTE   073h, 033h, 036h, 03Ch, 036h, 033h, 073h, 000h  ; K
	      36337300
1101:	C683  70303030	    .BYTE   070h, 030h, 030h, 030h, 031h, 033h, 07Fh, 000h  ; L
	      31337F00
1102:	C68B  63777F7F	    .BYTE   063h, 077h, 07Fh, 07Fh, 06Bh, 063h, 063h, 000h  ; M
	      6B636300
1103:	C693  63737B6F	    .BYTE   063h, 073h, 07Bh, 06Fh, 067h, 063h, 063h, 000h  ; N
	      67636300
1104:	C69B  1C366363	    .BYTE   01Ch, 036h, 063h, 063h, 063h, 036h, 01Ch, 000h  ; O
	      63361C00
1105:			    
1106:	C6A3  7E33333E	    .BYTE   07Eh, 033h, 033h, 03Eh, 030h, 030h, 078h, 000h  ; P
	      30307800
1107:	C6AB  3C666666	    .BYTE   03Ch, 066h, 066h, 066h, 066h, 06Eh, 03Ch, 00Eh  ; Q
	      666E3C0E
1108:	C6B3  7E33333E	    .BYTE   07Eh, 033h, 033h, 03Eh, 036h, 033h, 073h, 000h  ; R
	      36337300
1109:	C6BB  3C667038	    .BYTE   03Ch, 066h, 070h, 038h, 00Eh, 066h, 03Ch, 000h  ; S
	      0E663C00
1110:	C6C3  7E5A1818	    .BYTE   07Eh, 05Ah, 018h, 018h, 018h, 018h, 03Ch, 000h  ; T
	      18183C00
1111:	C6CB  66666666	    .BYTE   066h, 066h, 066h, 066h, 066h, 066h, 07Eh, 000h  ; U
	      66667E00
1112:	C6D3  66666666	    .BYTE   066h, 066h, 066h, 066h, 066h, 03Ch, 018h, 000h  ; V
	      663C1800
1113:	C6DB  6363636B	    .BYTE   063h, 063h, 063h, 06Bh, 07Fh, 077h, 063h, 000h  ; W
	      7F776300
1114:	C6E3  6363361C	    .BYTE   063h, 063h, 036h, 01Ch, 01Ch, 036h, 063h, 000h  ; X
	      1C366300
1115:	C6EB  6666663C	    .BYTE   066h, 066h, 066h, 03Ch, 018h, 018h, 03Ch, 000h  ; Y
	      18183C00
1116:	C6F3  7F63460C	    .BYTE   07Fh, 063h, 046h, 00Ch, 019h, 033h, 07Fh, 000h  ; Z
	      19337F00
1117:	C6FB  3C303030	    .BYTE   03Ch, 030h, 030h, 030h, 030h, 030h, 03Ch, 000h  ; [
	      30303C00
1118:	C703  6030180C	    .BYTE   060h, 030h, 018h, 00Ch, 006h, 003h, 001h, 000h  ; \
	      06030100
1119:	C70B  3C0C0C0C	    .BYTE   03Ch, 00Ch, 00Ch, 00Ch, 00Ch, 00Ch, 03Ch, 000h  ; ]
	      0C0C3C00
1120:	C713  183C7E18	    .BYTE   018h, 03Ch, 07Eh, 018h, 018h, 018h, 018h, 000h  ; ^
	      18181800
1121:	C71B  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 0FFh  ; underline
	      000000FF
1122:			    
1123:	C723  1F307C30	    .BYTE   01Fh, 030h, 07Ch, 030h, 07Ch, 030h, 01Fh, 000h  ; Pound/Euro
	      7C301F00
1124:	C72B  00003C06	    .BYTE   000h, 000h, 03Ch, 006h, 03Eh, 066h, 03Bh, 000h  ; a
	      3E663B00
1125:	C733  7030303E	    .BYTE   070h, 030h, 030h, 03Eh, 033h, 033h, 06Eh, 000h  ; b
	      33336E00
1126:	C73B  00003C66	    .BYTE   000h, 000h, 03Ch, 066h, 060h, 066h, 03Ch, 000h  ; c
	      60663C00
1127:	C743  0E06063E	    .BYTE   00Eh, 006h, 006h, 03Eh, 066h, 066h, 03Bh, 000h  ; d
	      66663B00
1128:	C74B  00003C66	    .BYTE   000h, 000h, 03Ch, 066h, 07Eh, 060h, 03Ch, 000h  ; e
	      7E603C00
1129:	C753  1C363078	    .BYTE   01Ch, 036h, 030h, 078h, 030h, 030h, 078h, 000h  ; f
	      30307800
1130:	C75B  00003B66	    .BYTE   000h, 000h, 03Bh, 066h, 066h, 03Eh, 006h, 07Ch  ; g
	      663E067C
1131:	C763  7030363B	    .BYTE   070h, 030h, 036h, 03Bh, 033h, 033h, 073h, 000h  ; h
	      33337300
1132:	C76B  18003818	    .BYTE   018h, 000h, 038h, 018h, 018h, 018h, 03Ch, 000h  ; i
	      18183C00
1133:	C773  06000606	    .BYTE   006h, 000h, 006h, 006h, 006h, 066h, 066h, 03Ch  ; j
	      0666663C
1134:	C77B  70303336	    .BYTE   070h, 030h, 033h, 036h, 03Ch, 036h, 073h, 000h  ; k
	      3C367300
1135:	C783  38181818	    .BYTE   038h, 018h, 018h, 018h, 018h, 018h, 03Ch, 000h  ; l
	      18183C00
1136:	C78B  0000667F	    .BYTE   000h, 000h, 066h, 07Fh, 07Fh, 06Bh, 063h, 000h  ; m
	      7F6B6300
1137:	C793  00007C66	    .BYTE   000h, 000h, 07Ch, 066h, 066h, 066h, 066h, 000h  ; n
	      66666600
1138:	C79B  00003C66	    .BYTE   000h, 000h, 03Ch, 066h, 066h, 066h, 03Ch, 000h  ; o
	      66663C00
1139:			    
1140:	C7A3  00006E33	    .BYTE   000h, 000h, 06Eh, 033h, 033h, 03Eh, 030h, 078h  ; p
	      333E3078
1141:	C7AB  00003B66	    .BYTE   000h, 000h, 03Bh, 066h, 066h, 03Eh, 006h, 00Fh  ; q
	      663E060F
1142:	C7B3  00006E3B	    .BYTE   000h, 000h, 06Eh, 03Bh, 033h, 030h, 078h, 000h  ; r
	      33307800
1143:	C7BB  00003E60	    .BYTE   000h, 000h, 03Eh, 060h, 03Ch, 006h, 07Ch, 000h  ; s
	      3C067C00
1144:	C7C3  08183E18	    .BYTE   008h, 018h, 03Eh, 018h, 018h, 01Ah, 00Ch, 000h  ; t
	      181A0C00
1145:	C7CB  00006666	    .BYTE   000h, 000h, 066h, 066h, 066h, 066h, 03Bh, 000h  ; u
	      66663B00
1146:	C7D3  00006666	    .BYTE   000h, 000h, 066h, 066h, 066h, 03Ch, 018h, 000h  ; v
	      663C1800
1147:	C7DB  0000636B	    .BYTE   000h, 000h, 063h, 06Bh, 07Fh, 07Fh, 036h, 000h  ; w
	      7F7F3600
1148:	C7E3  00006336	    .BYTE   000h, 000h, 063h, 036h, 01Ch, 036h, 063h, 000h  ; x
	      1C366300
1149:	C7EB  00006666	    .BYTE   000h, 000h, 066h, 066h, 066h, 03Eh, 006h, 07Ch  ; y
	      663E067C
1150:	C7F3  00007E4C	    .BYTE   000h, 000h, 07Eh, 04Ch, 018h, 032h, 07Eh, 000h  ; z
	      18327E00
1151:	C7FB  0E181870	    .BYTE   00Eh, 018h, 018h, 070h, 018h, 018h, 00Eh, 000h  ; {
	      18180E00
1152:	C803  18181818	    .BYTE   018h, 018h, 018h, 018h, 018h, 018h, 018h, 000h  ; |
	      18181800
1153:	C80B  7018180E	    .BYTE   070h, 018h, 018h, 00Eh, 018h, 018h, 070h, 000h  ; }
	      18187000
1154:	C813  3B6E0000	    .BYTE   03Bh, 06Eh, 000h, 000h, 000h, 000h, 000h, 000h  ; ~
	      00000000
1155:	C81B  3C4299A1	    .BYTE   03Ch, 042h, 099h, 0A1h, 0A1h, 099h, 042h, 03Ch  ; (c)
	      A199423C
1156:	C823          	charSetEnd:
1157:			
1158:			;==============================================================================
1159:	C823          	    .END



Statistics:

     4	passes
     0	jr promotions
   139	symbols
  2083	bytes

    47	macro calls
   273	macro bytes
     0	invented symbols



Symbol Table:

CF_DO_COLON    = EC3      3779
CHARRAM        =2C00      11264
DOCODE         =1A0E      6670
FORTH_LF       =3C47      15431
F_1PLUS        = E09      3593
F_2PLUS        = E13      3603
F_BASE         = 48A      1162
F_CFETCH       = 896      2198
F_CSTORE       = 8A5      2213
F_DIV          = D51      3409
F_DOT          = 9B3      2483
F_DUP          = 86B      2155
F_FETCH        = 8B3      2227
F_FIND         = 63D      1597
F_HERE         = 460      1120
F_MINUS        = DE1      3553
F_OVER         = 912      2322
F_PLUS         = DD2      3538
F_SEMICOLON    = 4B6      1206
F_STK_BYTE     =104B      4171
F_STK_WORD     =1011      4113
F_STORE        = 8C1      2241
F_SWAP         = 885      2181
PADEND         =2700      9984
PAGEDRAM       =8000      32768
PSG_REG        =FD        253
PSG_VAL        =FF        255
PSGenable      =07        7
PSGportA       =0E        14
PSGportB       =0F        15
RAMTOP         =3C18      15384
SCRNRAM        =2400      9216
SCRPOS         =3C1C      15388
SPARE          =3C3B      15419
UART_DATA      =E1        225
UART_DLL       =E1        225
UART_DLM       =E3        227
UART_IER       =E3        227
UART_IIR       =E5        229
UART_LCR       =E7        231
UART_LSR       =EB        235
UART_MCR       =E9        233
UART_MSR       =ED        237
UART_SCR       =EF        239
UFLOAT_NLF     =1D58      7512
UartCheck       3289      12937
UartCheckExit   329B      12955
UartExit        32BF      12991
UartRx          329C      12956
UartRxLoop      32AA      12970
UartRxWait      32A0      12960
UartSet         327A      12922
UartTx          32C7      12999
UartTxLoop      32D5      13013
UartTxWait      32CB      13003
XDICT          =3000      12288
XROM           =C000      49152
baudLink        3121      12577
baudName        311B      12571
blackLink       31C7      12743
blackName       31C0      12736
blueLink        31E5      12773
blueName        31DF      12767
borderLink      3169      12649
borderName      3161      12641
charSet         C423      50211
charSetEnd      C823      51235
clearScreen     C0EF      49391
clsLoop         C0F8      49400
cmove           325F      12895
cmoveLink       303C      12348
cmoveName       3035      12341
cmoveUp         3277      12919
colorBarLoop    C068      49256
countLink       3007      12295
countName       3000      12288
cyanLink        3202      12802
cyanName        31FC      12796
darkLink        324C      12876
darkName        3246      12870
depthLink       3069      12393
depthName       3062      12386
dictExp         C136      49462
dictExpEnd      C423      50211
drawBarPair     C048      49224
drawLongBar     C117      49431
drawShortBar    C109      49417
fill            3257      12887
fillLink        3052      12370
fillName        304C      12364
fontLink        3100      12544
fontName        30FA      12538
forthPopBC     = 84E      2126
greenLink       31F4      12788
greenName       31ED      12781
greyLink        31D7      12759
greyName        31D1      12753
hexLink         3089      12425
hexName         3084      12420
inkLink         3189      12681
inkName         3184      12676
longBarLoop     C119      49433
mpageLink       30C4      12484
mpageName       30BD      12477
paperLink       31A5      12709
paperName       319E      12702
printStr        C101      49409
psgrLink        30AE      12462
psgrName        30A8      12456
psgwLink        309B      12443
psgwName        3095      12437
pstoreLink      3018      12312
pstoreName      3014      12308
purpleLink      321F      12831
purpleName      3217      12823
questionLink    302C      12332
questionName    3029      12329
quitToForth    =9B        155
redBar          C12F      49455
redLink         320F      12815
redName         320A      12810
rxLink          3152      12626
rxName          314E      12622
scanKbrd       = 336      822
screenLink      30E1      12513
screenName      30D9      12505
shortBarLoop    C10B      49419
stackByteAndFinish 31CC      12748
strII           C127      49447
strJupiter      C11F      49439
strYear         C12A      49450
txLink          313F      12607
txName          313B      12603
waitKeyPress    C0CD      49357
waitKeyRelease  C0C7      49351
whiteLink       323E      12862
whiteName       3237      12855
yellowLink      322F      12847
yellowName      3227      12839
