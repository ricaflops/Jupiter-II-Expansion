   1:				;==============================================================================
   2:				; XROM for Jupiter-II Expansion
   3:				; 2020-Aug - Ricardo F. Lopes
   4:				; 
   5:				; Compile using Z80 ZMAC assembler: zmac xrom.z --oo lst,cim
   6:				;==============================================================================
   7:				
   8:				; Patch to the original Jupiter Ace ROM to link to this code
   9:				;   008E: C3 00 C0 00
  10:				; That patch inserts XROM in the original ROM initialization process flow
  11:				; Original Jupiter Ace ROM code:
  12:				;   008E: ED 56      IM 1      ; Set Interrupt mode 1
  13:				;   0090: 18 09      JR $009B  ; Quit to FORTH
  14:				; Code after patch applied:
  15:				;   008E: C3 00 C0   JP $C000  ; Redirect to XROM code
  16:				;   0091: 00         NOP       ; ---
  17:				
  18:				;-----------------------------
  19:				; Memory Locations
  20:     -	C000          	XROM        .EQU $C000  ; XROM image offset
  21:     -	3000          	XDICT       .EQU $3000  ; RAM area where extra FORTH words will reside
  22:     -	8000          	PAGEDRAM    .EQU $8000  ; RAM paging above this address
  23:     -	2400          	SCRNRAM     .EQU $2400  ; Screen Memory (video circuit priority)
  24:     -	2700          	PADEND      .EQU $2700  ; End of PAD marker
  25:     -	2C00          	CHARRAM     .EQU $2C00  ; Character Set RAM Memory (video circuit priority)
  26:     -	3C18          	RAMTOP      .EQU $3C18  ; System Variable: 2 bytes, RAM top address + 1
  27:     -	3C1C          	SCRPOS      .EQU $3C1C  ; System Variable: 2 bytes, Next print position in video RAM
  28:     -	3C47          	FORTH_LF    .EQU $3C47  ; FORTH word Link Field: point to last word Name Length Field
  29:     -	1D58          	UFLOAT_NLF  .EQU $1D58  ; UFLOAT word Name Length Field (last word in original ROM)
  30:     -	3C3B          	SPARE       .EQU $3C3B  ; System Variable: 2 bytes, TOS Address + 2
  31:				;-----------------------------
  32:				; Lower ROM routines
  33:     -	009B          	quitToForth .EQU $009B  ; FORTH QUIT
  34:     -	0336          	scanKbrd    .EQU $0336  ; Keyboard Scan, return key code in Accumulator, 0 if no key pressed
  35:     -	084E          	forthPopBC  .EQU $084E  ; Pop Top of Stack to BC register (affects HL)
  36:				;-----------------------------
  37:				; I/O Addresses: UART
  38:     -	00E1          	UART_DATA   .EQU $E1    ; Rx/Tx buffer register
  39:     -	00E1          	UART_DLL    .EQU $E1    ; Divisor Latch LSB (when DLAB=1)
  40:     -	00E3          	UART_IER    .EQU $E3    ; Interrupt Enable Register
  41:     -	00E3          	UART_DLM    .EQU $E3    ; Divisor Latch MSB (when DLAB=1)
  42:     -	00E5          	UART_IIR    .EQU $E5    ; IN: Interrupt Identifier Register
  43:     -	00E7          	UART_LCR    .EQU $E7    ; Line Control
  44:     -	00E9          	UART_MCR    .EQU $E9    ; Modem Control
  45:     -	00EB          	UART_LSR    .EQU $EB    ; Line Status
  46:     -	00ED          	UART_MSR    .EQU $ED    ; Modem Status
  47:     -	00EF          	UART_SCR    .EQU $EF    ; Scratch Register
  48:				;-----------------------------
  49:				; I/O Addresses: Programmabel Sound Generator
  50:     -	00FD          	PSG_REG     .EQU $FD    ; Z80 I/O address of PSG register selection
  51:     -	00FF          	PSG_VAL     .EQU $FF    ; Z80 I/O address of PSG register value
  52:				;-----------------------------
  53:				; rogrammabel Sound Generator Registers
  54:     -	0007          	PSGenable   .EQU 7      ; PSG Register: Output channel enables and I/O Ports direction
  55:     -	000E          	PSGportA    .EQU 14     ; PSG Register: Port A (PAPAER and INK color)
  56:     -	000F          	PSGportB    .EQU 15     ; PSG Register: Port B (BORDER color and Memory Paging)
  57:				;-----------------------------
  58:				; some FORTH dictionary code fields
  59:     -	0460          	F_HERE      .EQU $0460  ; HERE
  60:     -	048A          	F_BASE      .EQU $048A  ; BASE
  61:     -	04B6          	F_SEMICOLON .EQU $04B6  ; ;
  62:     -	063D          	F_FIND      .EQU $063D  ; FIND
  63:     -	0D51          	F_DIV       .EQU $0D51  ; /
  64:     -	086B          	F_DUP       .EQU $086B  ; DUP
  65:     -	0885          	F_SWAP      .EQU $0885  ; SWAP
  66:     -	0896          	F_CFETCH    .EQU $0896  ; C@
  67:     -	08A5          	F_CSTORE    .EQU $08A5  ; C!
  68:     -	08B3          	F_FETCH     .EQU $08B3  ; @
  69:     -	08C1          	F_STORE     .EQU $08C1  ; !
  70:     -	0912          	F_OVER      .EQU $0912  ; OVER
  71:     -	09B3          	F_DOT       .EQU $09B3  ; .
  72:     -	0DD2          	F_PLUS      .EQU $0DD2  ; +
  73:     -	0DE1          	F_MINUS     .EQU $0DE1  ; -
  74:     -	0E09          	F_1PLUS     .EQU $0E09  ; 1+
  75:     -	0E13          	F_2PLUS     .EQU $0E13  ; 2+
  76:     -	0EC3          	CF_DO_COLON .EQU $0EC3  ; DoColon
  77:     -	1011          	F_STK_WORD  .EQU $1011  ; Stack next word
  78:     -	104B          	F_STK_BYTE  .EQU $104B  ; Stack byte
  79:     -	1A0E          	DOCODE      .EQU $1A0E  ; from DO_COLON to ASM
  80:				
  81:				;==============================================================================
  82:				; Macros ======================================================================
  83:				;==============================================================================
  84:				
  85:				;-------------------------------
  86:				; Set PSG register value
  87:				PSGset .MACRO  value, register     
  88:				    LD    A, register
  89:				    OUT   (PSG_REG), A   ; Select PSG register
  90:				    LD    A, value
  91:				    OUT   (PSG_VAL), A   ; Set PSG register value
  92:				.ENDM
  93:				
  94:				;-------------------------------
  95:				; Print string at lin, col
  96:				PrintAt .MACRO lin, col, str
  97:				    LD    HL,str
  98:				    LD    DE,SCRNRAM + col + (lin * 32)
  99:					CALL  printStr
 100:				.ENDM
 101:				
 102:				;-------------------------------
 103:				; FORTH coding: Return back to FORTH
 104:				FORTHreturn .MACRO  
 105:				    JP   (IY)
 106:				.ENDM
 107:				
 108:				;-------------------------------
 109:				; FORTH coding: Pop DE from FORTH data stack
 110:				; Affects: HL
 111:				FORTHpop .MACRO
 112:				    RST  18H
 113:				.ENDM
 114:				
 115:				;-------------------------------
 116:				; FORTH coding: Push DE to FORTH Data stack
 117:				; Affects: HL
 118:				FORTHpush .MACRO 
 119:				    RST 10H
 120:				.ENDM
 121:				
 122:				;==============================================================================
 123:				; XROM ========================================================================
 124:				;==============================================================================
 125:     -	C000          	    .ORG    XROM
 126:				;-----------------------------  Initialize PSG
 127:    0+36	C000  3E0ED3FD	    PSGset 11110001b, PSGportA     ; PAPER = White, INK = Dark Blue
	              3EF1D3FF
 128:   36+36	C008  3E0FD3FD	    PSGset 10110011b, PSGportB     ; BORDER = Cyan, CharSet = 0, Screen = 0, Memory Page = 3
	              3EB3D3FF
 129:   72+36	C010  3E07D3FD	    PSGset 11111111b, PSGenable    ; Enable Ports A & B as outputs, disable Sound channels
	              3EFFD3FF
 130:				;-----------------------------  Install Character Set at FONT 0
 131:  108+10	C018  2113C4  	    LD    HL,charSet               ; Source: New Character set pattern
 132:  118+10	C01B  11002C  	    LD    DE,CHARRAM               ; Destination: Character Set RAM
 133:  128+10	C01E  010004  	    LD    BC,charSetEnd - charSet  ; Bytes to copy
 134:  138+16+5	C021  EDB0    	    LDIR                           ; Do copy
 135:				;-----------------------------  Install extra FORTH words
 136:  154+10	C023  2126C1  	    LD    HL,dictExp               ; Source: Extra FORTH words definition
 137:  164+10	C026  110030  	    LD    DE,XDICT                 ; Destination: Lower 1K RAM
 138:  174+10	C029  01ED02  	    LD    BC,dictExpEnd - dictExp  ; Bytes to copy
 139:  184+16+5	C02C  EDB0    	    LDIR                           ; Do copy
 140:				    ; Link Extra Words under FORTH word
 141:  200+10	C02E  214C32  	    LD    HL,darkLink              ; last defined extra word link field
 142:  210+16	C031  22473C  	    LD    (FORTH_LF),HL            ; Replace original FORTH link to include expanded dictionary
 143:				;----------------------------- Initialize Screen page 0	
 144:  226+17	C034  CDDFC0  		CALL   clearScreen             ; Clear screen page 0
 145:  243+4	C037  AF      	    XOR    A
 146:  247+13	C038  320027  	    LD     (PADEND),A              ; Set PAD End marker
 147:				;----------------------------- Splash Screen
 148:  260+36	C03B  3E0ED3FD	    PSGset 11111100b, PSGportA     ; PAPER = WHITE, INK = RED
	              3EFCD3FF
 149:				    ; draw 24 short red bars (12 pairs)
 150:  296+10	C043  210B24  	    LD   HL,SCRNRAM + 11  ; Screen Position destination lin=0, col=11
 151:  306+7	C046  060C    	    LD   B,12             ; Print 12 bar pairs
 152:     -	C048          	drawBarPair:
 153:  313+10	C048  111FC1  		LD   DE,redBar        ; Draw Bar pattern 1	
 154:  323+17	C04B  CDF9C0  	    CALL drawShortBar
 155:  340+10	C04E  1120C1  		LD   DE,redBar+1      ; Draw Bar pattern 2
 156:  350+17	C051  CDF9C0  	    CALL drawShortBar	
 157:  367+6	C054  2B      		DEC  HL               ; Move one screen column to the left
 158:  373+8+5	C055  10F1    		DJNZ drawBarPair      ; Draw next pair
 159:				    ; Draw first long red bar
 160:  381+10	C057  216E24  		LD    HL,SCRNRAM + 14 + (3 * 32) ; First bar at line 3, column 14
 161:  391+17	C05A  CD07C1  	    CALL  drawLongBar
 162:				    ; Draw second long red bar
 163:  408+10	C05D  218E24  		LD    HL,SCRNRAM + 14 + (4 * 32) ; Second bar at line 4, column 14
 164:  418+17	C060  CD07C1  	    CALL  drawLongBar
 165:				    ; Draw colors bar (INK=0..15)
 166:  435+10	C063  218826  	    LD    HL,SCRNRAM + 8 + (20 * 32) ; Color bar at line 20, column 8
 167:  445+7	C066  3EF0    	    LD    A,11110000b                ; PAPER = WHITE , INK = BLACK
 168:     -	C068          	colorBarLoop:                   ; loop through the 16 colors
 169:  452+11	C068  D3FF    	    OUT   (PSG_VAL),A           ; Set next INK color
 170:  463+10	C06A  3690    	    LD    (HL),90h              ; Print solid block character
 171:  473+6	C06C  23      	    INC   HL                    ; advance screen position
 172:  479+4	C06D  3C      	    INC   A                     ; next color code for INK
 173:  483+7+5	C06E  20F8    	    JR    NZ,colorBarLoop       ; end bar when color code wraps to zero
 174:				    ; Place Strings
 175:  490+7	C070  3EF1    	    LD    A,11110001b           ; PAPER = WHITE, INK = DARK BLUE
 176:  497+11	C072  D3FF    	    OUT   (PSG_VAL),A
 177:  508+37	C074  210FC111		PrintAt  3,  1, strJupiter  ; "Jupiter" at line  3, column  1
	              6124CDF1
	              C0
 178:  545+37	C07D  2117C111	    PrintAt  4,  6, strII       ; "II"      at line  4, column  6
	              8624CDF1
	              C0
 179:  582+37	C086  211AC111	    PrintAt 22, 14, strYear     ; "2020"    at line 22, column 14
	              CE26CDF1
	              C0
 180:				;----------------------------- Play Initialization Tone
 181:  619+36	C08F  3E00D3FD	    PSGset       203,  0        ; Tone A period = 1ms (1kHz)
	              3ECBD3FF
 182:  655+36	C097  3E07D3FD	    PSGset 11111110b,  7        ; Tone A enabled at Channel A
	              3EFED3FF
 183:  691+36	C09F  3E08D3FD	    PSGset        24,  8        ; Channel A Volume = 75%
	              3E18D3FF
 184:  727+36	C0A7  3E0CD3FD	    PSGset        25, 12        ; Envelope Period = 504 ms
	              3E19D3FF
 185:  763+36	C0AF  3E0DD3FD	    PSGset 00000001b, 13        ; Envelope ramps down one cycle
	              3E01D3FF
 186:				;----------------------------- Wait Keypress to clear screen
 187:     -	C0B7          	waitKeyRelease:
 188:  799+17	C0B7  CD3603  	    CALL  scanKbrd
 189:  816+4	C0BA  A7      	    AND   A
 190:  820+7+5	C0BB  20FA    		JR    NZ,waitKeyRelease
 191:     -	C0BD          	waitKeyPress:
 192:  827+17	C0BD  CD3603  	    CALL  scanKbrd
 193:  844+4	C0C0  A7      	    AND   A
 194:  848+7+5	C0C1  28FA    	    JR    Z,waitKeyPress
 195:				;----------------------------- Select Page 1 and Font set 1, Clear Screen
 196:  855+36	C0C3  3E0FD3FD		PSGset 10111111b, PSGportB  ; BORDER = Cyan, CharSet = 1, Screen = 1, Memory Page = 3
	              3EBFD3FF
 197:  891+17	C0CB  CDDFC0  	    CALL  clearScreen
 198:				;----------------------------- Initialize Serial Communication
 199:  908+10	C0CE  011800  	    LD    BC,24        ; UART Baud rate divisor for 9600 Baud
 200:  918+17	C0D1  CD7A32  	    CALL  UartSet      ; (subroutine at XDICT space)
 201:				;----------------------------- Limit RAMTOP to unpaged RAM and QUIT to FORTH
 202:  935+10	C0D4  210080  	    LD    HL,PAGEDRAM  ; Limit FORTH to unpaged RAM region below 32768
 203:  945+16	C0D7  22183C  	    LD    (RAMTOP),HL  ; This allows for memory paging without fuss
 204:  961+8	C0DA  ED56    		IM    1            ; Select interrupt mode 1 (this was removed  in ROM patching)
 205:  969+10	C0DC  C39B00  	    JP    quitToForth  ; Quit to FORTH
 206:				
 207:				;==============================================================================
 208:				; XROM Sub routines ===========================================================
 209:				;==============================================================================
 210:				
 211:				; -----------------------------
 212:				; Clear Screen 
 213:				; -----------------------------
 214:				; Fill screen RAM with space character
 215:				; Affects: A, BC, HL, Flags
 216:     -	C0DF          	clearScreen:
 217:  979+10	C0DF  210024  	    LD    HL,SCRNRAM   ; Start address = first screen position
 218:  989+16	C0E2  221C3C  	    LD    (SCRPOS),HL  ; Set cursor to Home (top left screen corner)
 219: 1005+10	C0E5  010003  		LD    BC,768       ; Screen positions to fill
 220:     -	C0E8          	clsLoop:
 221: 1015+10	C0E8  3620    	    LD    (HL),$20     ; Put SPACE char at current screen position
 222: 1025+6	C0EA  23      		INC   HL           ; Advance screen position
 223: 1031+6	C0EB  0B      		DEC   BC           ; Count positions done
 224: 1037+4	C0EC  78      		LD    A,B          ; Check if zero
 225: 1041+4	C0ED  B1      	    OR    C
 226: 1045+7+5	C0EE  20F8    		JR    NZ,clsLoop   ; keep filling until last screen position
 227: 1052+10	C0F0  C9      	    RET
 228:				
 229:				; -----------------------------
 230:				; Print String
 231:				; -----------------------------
 232:				; HL = source string address (first byte is string length)
 233:				; DE = destination address
 234:				; Affects: A, BC, HL, flags
 235:     -	C0F1          	printStr:
 236: 1062+7	C0F1  7E      	    LD    A,(HL)  ; Get string size
 237: 1069+4	C0F2  4F      		LD    C,A     ; BC = string length
 238: 1073+7	C0F3  0600    		LD    B,0
 239: 1080+6	C0F5  23      		INC   HL      ; HL = string first character
 240: 1086+16+5	C0F6  EDB0    		LDIR          ; Copy string to destination address
 241: 1102+10	C0F8  C9      		RET
 242:				
 243:				; -----------------------------
 244:				; Draw Short Horizontal Bar
 245:				; -----------------------------
 246:				; DE = points to bar pattern
 247:				; HL = points to screen position to start drawing the bar
 248:				; Affects: A, C, DE, HL
 249:				; Output: HL = next screen line position
 250:     -	C0F9          	drawShortBar:
 251: 1112+7	C0F9  0E06    		LD   C,6              ; Pattern is 6 chars wide
 252:     -	C0FB          	shortBarLoop:
 253: 1119+7	C0FB  1A      		LD   A,(DE)           ; get char from pattern
 254: 1126+7	C0FC  77      		LD   (HL),A           ; put on screen
 255: 1133+6	C0FD  13      		INC  DE               ; Move char source pointer
 256: 1139+6	C0FE  23      		INC  HL               ; Move screen destination pointer
 257: 1145+4	C0FF  0D      		DEC  C                ; chars countdown
 258: 1149+7+5	C100  20F9    		JR   NZ,shortBarLoop
 259:					
 260: 1156+10	C102  111A00  		LD   DE,26            ; move screen pointer to next line 
 261: 1166+11	C105  19      		ADD  HL,DE
 262: 1177+10	C106  C9      		RET
 263:					
 264:				; -----------------------------
 265:				; Draw Long Horizontal Bar
 266:				; -----------------------------
 267:				; Draw one long horizontal bar for splash screenString print routines
 268:				; HL = screen address
 269:				; Affects: B, HL, flags
 270:     -	C107          	drawLongBar:
 271: 1187+7	C107  0612    		LD    B,18         ; Bar length
 272:     -	C109          	longBarLoop:
 273: 1194+10	C109  3693    		LD    (HL),93h     ; Place half block character
 274: 1204+6	C10B  23      		INC   HL           ; Move to next screen position
 275: 1210+8+5	C10C  10FB    		DJNZ  longBarLoop  ; Draw next character
 276: 1218+10	C10E  C9      		RET
 277:				
 278:				;==============================================================================
 279:				; XROM Strings and constants ==================================================
 280:				;==============================================================================
 281:				
 282:     -	C10F  074A7570	strJupiter:  .BYTE   7, "Jupiter"
	              69746572
 283:     -	C117  024949  	strII:       .BYTE   2, "II"
 284:     -	C11A  04323032	strYear:     .BYTE   4, "2020"
	              30
 285:     -	C11F  14939393	redBar:      .BYTE   14h, 93h, 93h, 93h, 93h, 93h, 97h ; small graphic bar
	              939397
 286:				
 287:				;==============================================================================
 288:				; XDICT: FORTH Dictionary extension ===========================================
 289:				;==============================================================================
 290:     -	C126          	dictExp:
 291:				;##############################################################################
 292:     -	3000          	    .PHASE XDICT
 293:				;##############################################################################	
 294:				
 295:				;-------------------------------
 296:				; COUNT ( addr -- addr+1 c )
 297:				;-------------------------------
 298:				; Extract String length (code from the Jupiter Ace Manual)
 299:				; : COUNT DUP 1+ SWAP C@ ;
 300:     -	3000          	countName:
 301:     -	3000  434F554E	    .DC    "COUNT"       ; Name Field: (DC sets bit 7 of last char)
	              D4
 302:     -	3005  581D    	    .WORD  UFLOAT_NLF    ; Link Field: point to previous word Name Length Field
 303:     -	3007          	countLink:
 304:     -	3007  05      	    .BYTE  $ - countName - 2  ; Name Length Field
 305:     -	3008  C30E    	    .WORD  CF_DO_COLON        ; Code Field Address: a FORTH word
 306:				    ;----------
 307:     -	300A  6B08    	    .WORD  F_DUP            ; DUP
 308:     -	300C  090E    		.WORD  F_1PLUS          ; 1+
 309:     -	300E  8508    	    .WORD  F_SWAP           ; SWAP
 310:     -	3010  9608    	    .WORD  F_CFETCH         ; C@
 311:     -	3012  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 312:				
 313:				;-------------------------------
 314:				; +! ( n addr -- )
 315:				;-------------------------------
 316:				; Add 'n' to 'addr' variable (code from the Jupiter Ace Manual)
 317:				; : +! SWAP OVER @ + SWAP ! ;
 318:     -	3014          	pstoreName:
 319:     -	3014  2BA1    	    .DC    "+!"       ; Name Field: (DC sets bit 7 of last char)
 320:     -	3016  0730    	    .WORD  countLink  ; Link Field: point to previous word Name Length Field
 321:     -	3018          	pstoreLink:
 322:     -	3018  02      	    .BYTE  $ - pstoreName - 2  ; Name Length Field
 323:     -	3019  C30E    	    .WORD  CF_DO_COLON         ; Code Field Address: a FORTH word
 324:				    ;----------
 325:     -	301B  8508    	    .WORD  F_SWAP           ; SWAP
 326:     -	301D  1209    	    .WORD  F_OVER           ; OVER
 327:     -	301F  B308    		.WORD  F_FETCH          ; @
 328:     -	3021  D20D    		.WORD  F_PLUS           ; +
 329:     -	3023  8508    	    .WORD  F_SWAP           ; SWAP
 330:     -	3025  C108    		.WORD  F_STORE          ; !
 331:     -	3027  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 332:					
 333:				;-------------------------------
 334:				; ? ( addr -- )
 335:				;-------------------------------
 336:				; Print variable value (code from the Jupiter Ace Manual)
 337:				; : ? @ . ;
 338:     -	3029          	questionName:
 339:     -	3029  BF      	    .DC    "?"         ; Name Field: (DC sets bit 7 of last char)
 340:     -	302A  1830    	    .WORD  pstoreLink  ; Link Field: point to previous word Name Length Field
 341:     -	302C          	questionLink:
 342:     -	302C  01      	    .BYTE  $ - questionName - 2  ; Name Length Field
 343:     -	302D  C30E    	    .WORD  CF_DO_COLON           ; Code Field Address: a FORTH word
 344:				    ;----------
 345:     -	302F  B308    	    .WORD  F_FETCH          ; @
 346:     -	3031  B309    	    .WORD  F_DOT            ; .
 347:     -	3033  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 348:				
 349:				;-------------------------------
 350:				; CMOVE ( addr1 addr2 n -- )
 351:				;-------------------------------
 352:				; Move 'n' bytes from 'addr1' to 'addr2'
 353:     -	3035          	cmoveName:
 354:     -	3035  434D4F56	    .DC    "CMOVE"       ; Name Fieldh (DC sets bit 7 of last char)
	              C5
 355:     -	303A  2C30    	    .WORD  questionLink  ; Link Field: previous defined word in vocabulary
 356:     -	303C          	cmoveLink:
 357:     -	303C  05      	    .BYTE  $ - cmoveName - 2  ; Name Length Field
 358:     -	303D  3F30    	    .WORD  $ + 2              ; Code Field
 359:				    ;----------
 360: 1228+17	303F  CD4E08  		CALL  forthPopBC   ; BC = bytes to move (from Top of Stack)
 361: 1245+11	C168  DF      	    FORTHpop           ; Get destination address from Top of Stack to DE
 362: 1256+11	3043  D5      		PUSH  DE           ; Save Destination address
 363: 1267+11	C16A  DF      		FORTHpop           ; Get source address from Top of Stack to DE
 364: 1278+4	3045  EB      		EX    DE,HL        ; HL = Source address
 365: 1282+10	3046  D1      		POP   DE           ; DE = Destination address
 366: 1292+17	3047  CD5F32  	    CALL  cmove        ; Move Data Block
 367: 1309+8	C170  FDE9    	    FORTHreturn        ; Return back to FORTH
 368:				
 369:				;-------------------------------
 370:				; FILL ( addr n c -- )
 371:				;-------------------------------
 372:				; Fill 'n' bytes with 'c' value starting from 'addr'
 373:     -	304C          	fillName:
 374:     -	304C  46494CCC	    .DC    "FILL"     ; Name Fieldh (DC sets bit 7 of last char)
 375:     -	3050  3C30    	    .WORD  cmoveLink  ; Link Field: previous defined word in vocabulary
 376:     -	3052          	fillLink:
 377:     -	3052  04      	    .BYTE  $ - fillName - 2  ; Name Length Field
 378:     -	3053  5530    	    .WORD  $ + 2             ; Code Field
 379:				    ;----------
 380: 1317+11	C17B  DF      		FORTHpop          ; pop E = 'c' (D is irrelevant)
 381: 1328+4	3056  7B      	    LD    A,E         ; save 'c'
 382: 1332+17	3057  CD4E08  		CALL  forthPopBC  ; BC = 'n' (byte counter)
 383: 1349+11	C180  DF      		FORTHpop          ; pop DE = 'addr'
 384: 1360+4	305B  EB      		EX    DE,HL       ; HL = 'addr'
 385: 1364+4	305C  5F      		LD    E,A         ; E = 'c'
 386: 1368+17	305D  CD5732  	    CALL  fill        ; Fill memory block
 387: 1385+8	C186  FDE9    	    FORTHreturn       ; Return back to FORTH
 388:				
 389:				;-------------------------------
 390:				; DEPTH ( -- n )
 391:				;-------------------------------
 392:				; Data Stack Depth (code from the Jupiter Ace Manual)
 393:				; : DEPTH  15419 @ HERE 12 + - 2 / ;
 394:     -	3062          	depthName:
 395:     -	3062  44455054	    .DC    "DEPTH"      ; Name Field: (DC sets bit 7 of last char)
	              C8
 396:     -	3067  5230    	    .WORD  fillLink     ; Link Field: point to previous word Name Length Field
 397:     -	3069          	depthLink:
 398:     -	3069  05      	    .BYTE  $ - depthName - 2  ; Name Length Field
 399:     -	306A  C30E    	    .WORD  CF_DO_COLON        ; Code Field Address: a FORTH word
 400:				    ;----------
 401:     -	306C  1110    	    .WORD  F_STK_WORD       ; SPARE system variable
 402:     -	306E  3B3C    		.WORD  SPARE     
 403:     -	3070  B308    		.WORD  F_FETCH          ; @
 404:     -	3072  6004    	    .WORD  F_HERE           ; HERE
 405:     -	3074  1110    		.WORD  F_STK_WORD       ; 12
 406:     -	3076  0C00    	    .WORD  12        
 407:     -	3078  D20D    		.WORD  F_PLUS           ; +
 408:     -	307A  E10D    		.WORD  F_MINUS          ; -
 409:     -	307C  1110    		.WORD  F_STK_WORD       ; 2
 410:     -	307E  0200    		.WORD  2         
 411:     -	3080  510D    	    .WORD  F_DIV            ; /
 412:     -	3082  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)	
 413:				
 414:				;-------------------------------
 415:				;***** To Do: FORTH Words to add *****
 416:				;-------------------------------
 417:				; -TRAILING
 418:				; ( from the Ace Manual )
 419:				; : KEY ( -- c )  BEGIN INKEY ?DUP UNTIL ;
 420:				; : ' ( -- n )  FIND 2+ ;
 421:				; : .S ( print data stack contents )
 422:				;   15419 @ HERE 12 +
 423:				;   OVER OVER -
 424:				;   IF  ( if stack not empty )
 425:				;     DO
 426:				;       I @ . 2
 427:				;     +LOOP
 428:				;   ELSE  ( stack is empty)
 429:				;     DROP DROP
 430:				;   THEN
 431:				; ;
 432:					
 433:				;-------------------------------
 434:				; HEX ( -- )
 435:				;-------------------------------
 436:				; Change numeric base to Hexadecimal
 437:     -	3084          	hexName:
 438:     -	3084  4845D8  	    .DC    "HEX"         ; Name Field: (DC sets bit 7 of last char)
 439:     -	3087  6930    	    .WORD  depthLink     ; Link Field: point to previous word Name Length Field
 440:     -	3089          	hexLink:
 441:     -	3089  03      	    .BYTE  $ - hexName - 2  ; Name Length Field
 442:     -	308A  C30E    	    .WORD  CF_DO_COLON      ; Code Field Address: a FORTH word
 443:				    ;----------
 444:     -	308C  4B10    	    .WORD  F_STK_BYTE       ; push following byte to Data Stack
 445:     -	308E  10      		.BYTE  16
 446:     -	308F  8A04    	    .WORD  F_BASE           ; BASE
 447:     -	3091  A508    	    .WORD  F_CSTORE         ; C!
 448:     -	3093  B604    	    .WORD  F_SEMICOLON      ; ; (end Forth word definition)
 449:					
 450:				;-------------------------------
 451:				; PSG! ( c reg -- )
 452:				;-------------------------------
 453:				; Write 'c' to PSG register 'reg'
 454:     -	3095          	psgwName:
 455:     -	3095  505347A1	    .DC    "PSG!"       ; Name Fieldh (DC sets bit 7 of last char)
 456:     -	3099  8930    	    .WORD  hexLink      ; Link Field: point to previous word Name Length Field
 457:     -	309B          	psgwLink:
 458:     -	309B  04      	    .BYTE  $ - psgwName - 2  ; Name Length Field
 459:     -	309C  9E30    	    .WORD  $ + 2             ; Code Field
 460:				    ;----------
 461: 1393+11	C1C4  DF      	    FORTHpop         ; Pop DE from FORTH data stack
 462: 1404+4	309F  7B      	    LD   A,E         ; Use only the lower byte
 463: 1408+11	30A0  D3FD    	    OUT  (PSG_REG),A ; Select PSG register
 464:				
 465: 1419+11	C1C8  DF      	    FORTHpop         ; Pop DE from FORTH data stack
 466: 1430+4	30A3  7B      	    LD   A,E         ; Use only the lower byte
 467: 1434+11	30A4  D3FF    	    OUT  (PSG_VAL),A ; Set selected PSG register value
 468: 1445+8	C1CC  FDE9    	    FORTHreturn      ; Return to FORTH
 469:				
 470:				;-------------------------------
 471:				; PSG@ ( reg -- c )
 472:				;-------------------------------
 473:				; Read PSG register 'reg' contents
 474:     -	30A8          	psgrName:
 475:     -	30A8  505347C0	    .DC    "PSG@"     ; Name Fieldh (DC sets bit 7 of last char)
 476:     -	30AC  9B30    	    .WORD  psgwLink   ; Link Field: previous defined word in vocabulary
 477:     -	30AE          	psgrLink:
 478:     -	30AE  04      	    .BYTE  $ - psgrName - 2  ; Name Length Field
 479:     -	30AF  B130    	    .WORD  $ + 2             ; Code Field
 480:				    ;----------
 481: 1453+11	C1D7  DF      	    FORTHpop         ; Pop DE from FORTH data stack
 482: 1464+4	30B2  7B      	    LD   A,E         ; Use only the lower byte
 483: 1468+11	30B3  D3FD    	    OUT  (PSG_REG),A ; Select PSG register
 484: 1479+11	30B5  DBFF    	    IN   A,(PSG_VAL) ; Read selected PSG register
 485: 1490+4	30B7  5F      	    LD   E,A         ; Data is a single byte
 486: 1494+4	30B8  AF      	    XOR  A           ; Clear D
 487: 1498+4	30B9  57      	    LD   D,A
 488: 1502+11	C1E0  D7      	    FORTHpush        ; Push DE to FORTH data stack
 489: 1513+8	C1E1  FDE9    	    FORTHreturn      ; Return to FORTH
 490:				
 491:				;-------------------------------
 492:				; MPAGE ( c -- )
 493:				;-------------------------------
 494:				; Select memory page 'c' , 0 to 3
 495:     -	30BD          	mpageName:
 496:     -	30BD  4D504147	    .DC    "MPAGE"    ; Name Fieldh (DC sets bit 7 of last char)
	              C5
 497:     -	30C2  AE30    	    .WORD  psgrLink   ; Link Field: previous defined word in vocabulary
 498:     -	30C4          	mpageLink:
 499:     -	30C4  05      	    .BYTE  $ - mpageName - 2  ; Name Length Field
 500:     -	30C5  C730    	    .WORD  $ + 2              ; Code Field
 501:				    ;----------
 502: 1521+7	30C7  3E0F    	    LD    A,PSGportB   ; Select PSG Port B Register
 503: 1528+11	30C9  D3FD    	    OUT   (PSG_REG),A
 504: 1539+11	30CB  DBFF    	    IN    A,(PSG_VAL)  ; Read PSG Port B
 505: 1550+7	30CD  E6FC    	    AND   11111100b    ; mask out mem page bits
 506: 1557+4	30CF  4F      	    LD    C,A          ; save BORDER color, screen page and char set
 507:				    
 508: 1561+11	C1F6  DF      	    FORTHpop           ; Pop DE from FORTH data stack
 509: 1572+4	30D1  7B      	    LD    A,E          ; memory page
 510: 1576+7	30D2  E603    	    AND   00000011b    ; limit memory paging to 0..3
 511: 1583+4	30D4  B1      	    OR    C            ; combine with saved BORDER color, screen page and char set
 512: 1587+11	30D5  D3FF    	    OUT   (PSG_VAL),A  ; Write to PSG Port B
 513: 1598+8	C1FD  FDE9    	    FORTHreturn        ; Return to FORTH
 514:				
 515:				;-------------------------------
 516:				; SCREEN ( c --  )
 517:				;-------------------------------
 518:				; Select Screen page 'c' , 0 or 1
 519:     -	30D9          	screenName:
 520:     -	30D9  53435245	    .DC    "SCREEN"   ; Name Fieldh (DC sets bit 7 of last char)
	              45CE
 521:     -	30DF  C430    	    .WORD  mpageLink  ; Link Field: previous defined word in vocabulary
 522:     -	30E1          	screenLink:
 523:     -	30E1  06      	    .BYTE  $ - screenName - 2  ; Name Length Field
 524:     -	30E2  E430    	    .WORD  $ + 2               ; Code Field
 525:				    ;----------
 526: 1606+7	30E4  3E0F    	    LD   A,PSGportB   ; Select PSG Port B Register
 527: 1613+11	30E6  D3FD    	    OUT  (PSG_REG),A
 528: 1624+11	30E8  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port B value
 529: 1635+7	30EA  E6FB    	    AND  11111011b    ; mask out Screen page bit 
 530: 1642+4	30EC  4F      	    LD   C,A          ; save BORDER color, memory and char set paging
 531:				    
 532: 1646+11	C213  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 533: 1657+4	30EE  7B      	    LD   A,E          ; screen page
 534: 1661+7	30EF  E601    	    AND  00000001b    ; limit Screen page to 0 or 1
 535: 1668+8	30F1  CB27    	    SLA  A            ; move to bit-2 position
 536: 1676+8	30F3  CB27    	    SLA  A
 537: 1684+4	30F5  B1      	    OR   C            ; combine with saved BORDER color, memory page and char set
 538: 1688+11	30F6  D3FF    	    OUT  (PSG_VAL),A  ; Write to PSG Port B
 539: 1699+8	C21E  FDE9    	    FORTHreturn       ; Return to FORTH
 540:				
 541:				;-------------------------------
 542:				; FONT ( c --  )
 543:				;-------------------------------
 544:				; Select character set 'c' , 0 or 1
 545:     -	30FA          	fontName:
 546:     -	30FA  464F4ED4	    .DC    "FONT"     ; Name Fieldh (DC sets bit 7 of last char)
 547:     -	30FE  E130    	    .WORD  screenLink ; Link Field: previous defined word in vocabulary
 548:     -	3100          	fontLink:
 549:     -	3100  04      	    .BYTE  $ - fontName - 2  ; Name Length Field
 550:     -	3101  0331    	    .WORD  $ + 2             ; Code Field
 551:				    ;----------
 552: 1707+7	3103  3E0F    	    LD   A,PSGportB   ; Select PSG Port B Register
 553: 1714+11	3105  D3FD    	    OUT  (PSG_REG),A
 554: 1725+11	3107  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port B value
 555: 1736+7	3109  E6F7    	    AND  11110111b    ; mask out char set bit 
 556: 1743+4	310B  4F      	    LD   C,A          ; save BORDER color, memory and screen pages
 557:				    
 558: 1747+11	C232  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 559: 1758+4	310D  7B      	    LD   A,E          ; character set
 560: 1762+7	310E  E601    	    AND  00000001b    ; limit Character Set paging to 0 or 1
 561: 1769+8	3110  CB27    	    SLA  A            ; move to bit-3 position
 562: 1777+8	3112  CB27    	    SLA  A
 563: 1785+8	3114  CB27    	    SLA  A
 564: 1793+4	3116  B1      	    OR   C            ; combine with saved BORDER color, memory and screen pages
 565: 1797+11	3117  D3FF    	    OUT  (PSG_VAL),A  ; Write to PSG Port B
 566: 1808+8	C23F  FDE9    	    FORTHreturn       ; Return to FORTH
 567:				
 568:				;-------------------------------
 569:				; BAUD ( n --  )
 570:				;-------------------------------
 571:				; Set UART to Baud rate 'n'
 572:     -	311B          	baudName:
 573:     -	311B  424155C4	    .DC    "BAUD"    ; Name Fieldh (DC sets bit 7 of last char)
 574:     -	311F  0031    	    .WORD  fontLink  ; Link Field: previous defined word in vocabulary
 575:     -	3121          	baudLink:
 576:     -	3121  04      	    .BYTE  $ - baudName - 2  ; Name Length Field
 577:     -	3122  C30E    	    .WORD  CF_DO_COLON       ; Code Field
 578:				    ;----------
 579:     -	3124  4B10    		.WORD  F_STK_BYTE   ; 10
 580:     -	3126  0A      		.BYTE  10
 581:     -	3127  510D    		.WORD  F_DIV        ; /
 582:     -	3129  1110    		.WORD  F_STK_WORD   ; 23040
 583:     -	312B  005A    	    .WORD  23040
 584:     -	312D  8508    	    .WORD  F_SWAP       ; SWAP	
 585:     -	312F  510D    	    .WORD  F_DIV        ; /  (result is baud divider)
 586:     -	3131  0E1A    		.WORD  DOCODE       ; execute following Asm code
 587: 1816+17	3133  CD4E08  		CALL   forthPopBC   ; BC = UART Baud rate divisor
 588: 1833+17	3136  CD7A32  		CALL   UartSet      ; UART setup
 589: 1850+8	C25F  FDE9    	    FORTHreturn         ; Return back to FORTH
 590:				
 591:				;-------------------------------
 592:				; TX ( addr n --  )
 593:				;-------------------------------
 594:				; Transmit 'n' bytes from 'addr' to serial line
 595:     -	313B          	txName:
 596:     -	313B  54D8    	    .DC    "TX"      ; Name Fieldh (DC sets bit 7 of last char)
 597:     -	313D  2131    	    .WORD  baudLink  ; Link Field: previous defined word in vocabulary
 598:     -	313F          	txLink:
 599:     -	313F  02      	    .BYTE  $ - txName - 2  ; Name Length Field
 600:     -	3140  4231    	    .WORD  $ + 2           ; Code Field
 601:				    ;----------
 602: 1858+17	3142  CD4E08  		CALL   forthPopBC      ; pop BC = 'n' from Data Stack
 603: 1875+11	C26B  DF      		FORTHpop               ; pop DE = 'addr' from data stack
 604: 1886+4	3146  EB      		EX     DE,HL           ; HL = 'addr' = Starting address
 605: 1890+4	3147  50      		LD     D,B             ; DE = 'n'    = Number of bytes to transmit
 606: 1894+4	3148  59      		LD     E,C
 607: 1898+17	3149  CDC732  		CALL   UartTx          ; Transmit Serial Data Block
 608: 1915+8	C272  FDE9    	    FORTHreturn            ; Return back to FORTH
 609:				
 610:				;-------------------------------
 611:				; RX ( addr n --  )
 612:				;-------------------------------
 613:				; Receive 'n' bytes from serial line to 'addr'
 614:     -	314E          	rxName:
 615:     -	314E  52D8    	    .DC    "RX"    ; Name Fieldh (DC sets bit 7 of last char)
 616:     -	3150  3F31    	    .WORD  txLink  ; Link Field: previous defined word in vocabulary
 617:     -	3152          	rxLink:
 618:     -	3152  02      	    .BYTE  $ - rxName - 2  ; Name Length Field
 619:     -	3153  5531    	    .WORD  $ + 2           ; Code Field
 620:				    ;----------
 621: 1923+17	3155  CD4E08  		CALL   forthPopBC      ; pop BC = 'n' from Data Stack
 622: 1940+11	C27E  DF      	    FORTHpop               ; pop DE = 'addr' from Data Stack
 623: 1951+4	3159  EB      		EX     DE,HL           ; HL = 'addr' = Starting address
 624: 1955+4	315A  50      		LD     D,B             ; DE = 'n'    = Number of bytes to receive
 625: 1959+4	315B  59      		LD     E,C
 626: 1963+17	315C  CD9C32  		CALL   UartRx          ; Receive Serial Data Block
 627: 1980+8	C285  FDE9    	    FORTHreturn            ; Return back to FORTH
 628:					
 629:				;-------------------------------
 630:				; BORDER ( c --  )
 631:				;-------------------------------
 632:				; Set screen BORDER to color 'c' , 0 to 15
 633:     -	3161          	borderName:
 634:     -	3161  424F5244	    .DC    "BORDER"  ; Name Fieldh (DC sets bit 7 of last char)
	              45D2
 635:     -	3167  5231    	    .WORD  rxLink    ; Link Field: previous defined word in vocabulary
 636:     -	3169          	borderLink:
 637:     -	3169  06      	    .BYTE  $ - borderName - 2  ; Name Length Field
 638:     -	316A  6C31    	    .WORD  $ + 2               ; Code Field
 639:				    ;----------
 640: 1988+7	316C  3E0F    	    LD   A,PSGportB   ; Select PSG Port B Register
 641: 1995+11	316E  D3FD    	    OUT  (PSG_REG),A
 642: 2006+11	3170  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port B value
 643: 2017+7	3172  E60F    	    AND  00001111b    ; mask out BORDER color
 644: 2024+4	3174  4F      	    LD   C,A          ; save memory and screen pages and char set
 645: 2028+11	C29B  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 646: 2039+4	3176  7B      	    LD   A,E          ; A = BORDER color
 647: 2043+8	3177  CB27    	    SLA  A            ; position BORDER color at the higher 4 bits
 648: 2051+8	3179  CB27    	    SLA  A            ; (also limiting BORDER color to 0..15)
 649: 2059+8	317B  CB27    	    SLA  A
 650: 2067+8	317D  CB27    	    SLA  A
 651: 2075+4	317F  B1      	    OR   C            ; combine with saved memory and screen pages and char set
 652: 2079+11	3180  D3FF    	    OUT  (PSG_VAL),A  ; Write back to Port A
 653: 2090+8	C2A8  FDE9    	    FORTHreturn       ; Return back to FORTH
 654:					
 655:				;-------------------------------
 656:				; INK ( c -- )
 657:				;-------------------------------
 658:				; Set character INK (foreground) to color 'c' , 0 to 15
 659:     -	3184          	inkName:
 660:     -	3184  494ECB  	    .DC    "INK"       ; Name Fieldh (DC sets bit 7 of last char)
 661:     -	3187  6931    	    .WORD  borderLink  ; Link Field: previous defined word in vocabulary
 662:     -	3189          	inkLink:
 663:     -	3189  03      	    .BYTE  $ - inkName - 2  ; Name Length Field
 664:     -	318A  8C31    	    .WORD  $ + 2            ; Code Field
 665:				    ;----------
 666: 2098+7	318C  3E0E    	    LD   A,PSGportA   ; Select PSG Port A Register
 667: 2105+11	318E  D3FD    	    OUT  (PSG_REG),A
 668: 2116+11	3190  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port A value
 669: 2127+7	3192  E6F0    	    AND  11110000b    ; mask out current INK color
 670: 2134+4	3194  4F      	    LD   C,A          ; save PAPER color
 671: 2138+11	C2BB  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 672: 2149+4	3196  7B      	    LD   A,E          ; A = INK color
 673: 2153+7	3197  E60F    	    AND  00001111b    ; limit INK color to 0..15
 674: 2160+4	3199  B1      	    OR   C            ; combine with saved PAPER color
 675: 2164+11	319A  D3FF    	    OUT  (PSG_VAL),A  ; Write back to Port A
 676: 2175+8	C2C2  FDE9    	    FORTHreturn       ; Return back to FORTH
 677:				
 678:				;-------------------------------
 679:				; PAPER ( c -- )
 680:				;-------------------------------
 681:				; Set character PAPER (background) color to 'c' , 0 to 15
 682:     -	319E          	paperName:
 683:     -	319E  50415045	    .DC    "PAPER"    ; Name Fieldh (DC sets bit 7 of last char)
	              D2
 684:     -	31A3  8931    	    .WORD  inkLink    ; Link Field: previous defined word in vocabulary
 685:     -	31A5          	paperLink:
 686:     -	31A5  05      	    .BYTE  $ - paperName - 2  ; Name Length Field
 687:     -	31A6  A831    	    .WORD  $ + 2              ; Code Field
 688:				    ;----------
 689: 2183+7	31A8  3E0E    	    LD   A,PSGportA   ; Select PSG Port A Register
 690: 2190+11	31AA  D3FD    	    OUT  (PSG_REG),A
 691: 2201+11	31AC  DBFF    	    IN   A,(PSG_VAL)  ; Read PSG Port A value
 692: 2212+7	31AE  E60F    	    AND  00001111b    ; mask out current PAPER color, preserving INK color
 693: 2219+4	31B0  4F      	    LD   C,A          ; save INK color
 694: 2223+11	C2D7  DF      	    FORTHpop          ; Pop DE from FORTH data stack
 695: 2234+4	31B2  7B      	    LD   A,E          ; A = PAPER color
 696: 2238+8	31B3  CB27    	    SLA  A            ; position PAPER color at the higher 4 bits
 697: 2246+8	31B5  CB27    	    SLA  A            ; (also limits PAPER color to 0..15)
 698: 2254+8	31B7  CB27    	    SLA  A
 699: 2262+8	31B9  CB27    	    SLA  A
 700: 2270+4	31BB  B1      	    OR   C            ; combine with saved INK color
 701: 2274+11	31BC  D3FF    	    OUT  (PSG_VAL),A  ; Write back to Port A
 702: 2285+8	C2E4  FDE9    	    FORTHreturn       ; Return back to FORTH
 703:				
 704:				;-------------------------------
 705:				; BLACK ( -- c )
 706:				;-------------------------------
 707:     -	31C0          	blackName:
 708:     -	31C0  424C4143	    .DC    "BLACK"    ; Name Fieldh (DC sets bit 7 of last char)
	              CB
 709:     -	31C5  A531    	    .WORD  paperLink  ; Link Field: previous defined word in vocabulary
 710:     -	31C7          	blackLink:
 711:     -	31C7  05      	    .BYTE  $ - blackName - 2  ; Name Length Field
 712:     -	31C8  CA31    	    .WORD  $ + 2              ; Code Field
 713:				    ;----------
 714: 2293+7	31CA  1E00    		LD    E,0                 ; Black color
 715:     -	31CC          	stackByteAndFinish:
 716: 2300+7	31CC  1600    	    LD    D,0                 ; Clear High byte
 717: 2307+11	C2F4  D7      		FORTHpush                 ; Push DE to FORTH data stack
 718: 2318+8	C2F5  FDE9    	    FORTHreturn               ; Return back to FORTH
 719:				
 720:				;-------------------------------
 721:				; GREY ( -- c )
 722:				;-------------------------------
 723:				; 8 CONSTANT
 724:     -	31D1          	greyName:
 725:     -	31D1  475245D9	    .DC    "GREY"     ; Name Fieldh (DC sets bit 7 of last char)
 726:     -	31D5  C731    	    .WORD  blackLink  ; Link Field: previous defined word in vocabulary
 727:     -	31D7          	greyLink:
 728:     -	31D7  04      	    .BYTE  $ - greyName - 2  ; Name Length Field
 729:     -	31D8  DA31    	    .WORD  $ + 2             ; Code Field
 730:				    ;----------
 731: 2326+7	31DA  1E08    	    LD    E,1000b            ; Grey color
 732: 2333+10	31DC  C3CC31  		JP    stackByteAndFinish
 733:				
 734:				;-------------------------------
 735:				; BLUE ( -- c )
 736:				;-------------------------------
 737:     -	31DF          	blueName:
 738:     -	31DF  424C55C5	    .DC    "BLUE"     ; Name Fieldh (DC sets bit 7 of last char))
 739:     -	31E3  D731    	    .WORD  greyLink   ; Link Field: previous defined word in vocabulary
 740:     -	31E5          	blueLink:
 741:     -	31E5  04      	    .BYTE  $ - blueName - 2  ; Name Length Field
 742:     -	31E6  E831    	    .WORD  $ + 2             ; Code Field
 743:				    ;----------
 744: 2343+7	31E8  1E09    	    LD    E,1001b            ; Blue color
 745: 2350+10	31EA  C3CC31  		JP    stackByteAndFinish
 746:				
 747:				;-------------------------------
 748:				; GREEN ( -- c )
 749:				;-------------------------------
 750:     -	31ED          	greenName:
 751:     -	31ED  47524545	    .DC    "GREEN"    ; Name Fieldh (DC sets bit 7 of last char)
	              CE
 752:     -	31F2  E531    	    .WORD  blueLink   ; Link Field: previous defined word in vocabulary
 753:     -	31F4          	greenLink:
 754:     -	31F4  05      	    .BYTE  $ - greenName - 2  ; Name Length Field
 755:     -	31F5  F731    	    .WORD  $ + 2              ; Code Field
 756:				    ;----------
 757: 2360+7	31F7  1E0A    	    LD    E,1010b             ; Green color
 758: 2367+10	31F9  C3CC31  		JP    stackByteAndFinish
 759:				
 760:				;-------------------------------
 761:				; CYAN ( -- c )
 762:				;-------------------------------
 763:     -	31FC          	cyanName:
 764:     -	31FC  435941CE	    .DC    "CYAN"     ; Name Fieldh (DC sets bit 7 of last char)
 765:     -	3200  F431    	    .WORD  greenLink  ; Link Field: previous defined word in vocabulary
 766:     -	3202          	cyanLink:
 767:     -	3202  04      	    .BYTE  $ - cyanName - 2  ; Name Length Field
 768:     -	3203  0532    	    .WORD  $ + 2             ; Code Field
 769:				    ;----------
 770: 2377+7	3205  1E0B    	    LD    E,1011b            ; Cyan color
 771: 2384+10	3207  C3CC31  		JP    stackByteAndFinish
 772:				
 773:				;-------------------------------
 774:				; RED ( -- c )
 775:				;-------------------------------
 776:     -	320A          	redName:
 777:     -	320A  5245C4  	    .DC    "RED"      ; Name Fieldh (DC sets bit 7 of last char)
 778:     -	320D  0232    	    .WORD  cyanLink   ; Link Field: previous defined word in vocabulary
 779:     -	320F          	redLink:
 780:     -	320F  03      	    .BYTE  $ - redName - 2  ; Name Length Field
 781:     -	3210  1232    	    .WORD  $ + 2            ; Code Field
 782:				    ;----------
 783: 2394+7	3212  1E0C    	    LD    E,1100b           ; Red color
 784: 2401+10	3214  C3CC31  		JP    stackByteAndFinish
 785:				
 786:				;-------------------------------
 787:				; PURPLE ( -- c )
 788:				;-------------------------------
 789:     -	3217          	purpleName:
 790:     -	3217  50555250	    .DC    "PURPLE"  ; Name Fieldh (DC sets bit 7 of last char)
	              4CC5
 791:     -	321D  0F32    	    .WORD  redLink   ; Link Field: previous defined word in vocabulary
 792:     -	321F          	purpleLink:
 793:     -	321F  06      	    .BYTE  $ - purpleName - 2  ; Name Length Field
 794:     -	3220  2232    	    .WORD  $ + 2               ; Code Field
 795:				    ;----------
 796: 2411+7	3222  1E0D    	    LD    E,1101b              ; Purple color
 797: 2418+10	3224  C3CC31  		JP    stackByteAndFinish
 798:				
 799:				;-------------------------------
 800:				; YELLOW ( -- c )
 801:				;-------------------------------
 802:     -	3227          	yellowName:
 803:     -	3227  59454C4C	    .DC    "YELLOW"    ; Name Fieldh (DC sets bit 7 of last char)
	              4FD7
 804:     -	322D  1F32    	    .WORD  purpleLink  ; Link Field: previous defined word in vocabulary
 805:     -	322F          	yellowLink:
 806:     -	322F  06      	    .BYTE  $ - yellowName - 2  ; Name Length Field
 807:     -	3230  3232    	    .WORD  $ + 2               ; Code Field
 808:				    ;----------
 809: 2428+7	3232  1E0E    	    LD    E,1110b              ; Yellow color
 810: 2435+10	3234  C3CC31  		JP    stackByteAndFinish
 811:				
 812:				;-------------------------------
 813:				; WHITE ( -- c )
 814:				;-------------------------------
 815:     -	3237          	whiteName:
 816:     -	3237  57484954	    .DC    "WHITE"     ; Name Fieldh (DC sets bit 7 of last char)
	              C5
 817:     -	323C  2F32    	    .WORD  yellowLink  ; Link Field: previous defined word in vocabulary
 818:     -	323E          	whiteLink:
 819:     -	323E  05      	    .BYTE  $ - whiteName - 2  ; Name Length Field
 820:     -	323F  4132    	    .WORD  $ + 2              ; Code Field
 821:				    ;----------
 822: 2445+7	3241  1E0F    	    LD    E,1111b             ; White color
 823: 2452+10	3243  C3CC31  		JP    stackByteAndFinish
 824:				
 825:				;-------------------------------
 826:				; DARK ( c1 -- c2 )
 827:				;-------------------------------
 828:				; Change color code on stack to darker tone
 829:     -	3246          	darkName:
 830:     -	3246  444152CB	    .DC    "DARK"     ; Name Fieldh (DC sets bit 7 of last char)
 831:     -	324A  3E32    	    .WORD  whiteLink  ; Link Field: previous defined word in vocabulary
 832:     -	324C          	darkLink:
 833:     -	324C  04      	    .BYTE  $ - darkName - 2  ; Name Length Field
 834:     -	324D  4F32    	    .WORD  $ + 2             ; Code Field
 835:				    ;----------
 836: 2462+11	C375  DF      	    FORTHpop                 ; Pop from FORTH data stack to DE
 837: 2473+4	3250  7B      	    LD    A,E                ; Get lower byte
 838: 2477+7	3251  E607    	    AND   0111b              ; Clear intensity bit3
 839: 2484+4	3253  5F      	    LD    E,A                ; Put it back in Data Stack
 840: 2488+10	3254  C3CC31  	    JP    stackByteAndFinish
 841:				
 842:				;------------------------------------------------------------------------------
 843:				; XDICT Subroutines -----------------------------------------------------------
 844:				;------------------------------------------------------------------------------
 845:				
 846:				;-------------------------------
 847:				; Fill memory block
 848:				; Input: HL = Starting address to fill
 849:				;        BC = Number of bytes to fill
 850:				;        E  = Filling byte value
 851:     -	3257          	fill:
 852: 2498+4	3257  78      	    LD    A,B         ; Check if block size is zero
 853: 2502+4	3258  B1      	    OR    C
 854: 2506+5+6	3259  C8      		RET   Z           ; If block size = 0 , Exit loop
 855:					;----
 856: 2511+7	325A  73      	    LD    (HL),E      ; write one byte
 857: 2518+6	325B  23      	    INC   HL          ; move to next address
 858: 2524+6	325C  0B      		DEC   BC          ; Number of bytes Countdown
 859: 2530+12	325D  18F8    		JR    fill        ; Fill loop
 860:				
 861:				;-------------------------------
 862:				; Block move code based on 'Z80 Assembly Language Routines' from 'Lance A. Leventhal'
 863:				; Input: HL = Source address
 864:				;        DE = Destination address
 865:				;        BC = Number of bytes to move
 866:				; Affects: AF, BC, DE, HL
 867:     -	325F          	cmove:
 868: 2542+4	325F  78      	    LD    A,B    ; check if zero bytes to move
 869: 2546+4	3260  B1      		OR    C
 870: 2550+5+6	3261  C8      		RET   Z      ; if zero bytes to move , Abort
 871:					; check for overlaping regions
 872: 2555+4	3262  EB      	    EX    DE,HL   ; calculate destination - source
 873: 2559+11	3263  E5      		PUSH  HL      ; save destination address
 874: 2570+4	3264  A7      		AND   A       ; prepare for subtraction (clear carry)
 875: 2574+15	3265  ED52    		SBC   HL,DE   ; HL = destination - source
 876: 2589+4	3267  A7      		AND   A       ; prepare for subtraction (clear carry)
 877: 2593+15	3268  ED42    		SBC   HL,BC   ; subtract size
 878: 2608+10	326A  E1      		POP   HL      ; restore destination address
 879: 2618+4	326B  EB      		EX    DE,HL   ; HL = source , DE = destinattion
 880: 2622+7+5	326C  3009    		JR    NC,cmoveUp ; no overlaping , move up
 881:					; Destination area is above and overlaps with source
 882:					; move from highest address avoiding data destruction
 883: 2629+11	326E  09      		ADD   HL,BC     ; sourceHigh = sourceLow + length - 1
 884: 2640+6	326F  2B      		DEC   HL
 885: 2646+4	3270  EB      		EX    DE,HL
 886: 2650+11	3271  09      		ADD   HL,BC     ; destHigh = destLo + length - 1
 887: 2661+6	3272  2B      		DEC   HL
 888: 2667+4	3273  EB      		EX    DE,HL     ; HL = source , DE = destination
 889: 2671+16+5	3274  EDB8    		LDDR            ; Block move high to low
 890: 2687+10	3276  C9      		RET
 891:     -	3277          	cmoveUp:
 892: 2697+16+5	3277  EDB0    	    LDIR            ; Block move low to high
 893: 2713+10	3279  C9      		RET
 894:				
 895:				;------------------------------- (UART 16C450)
 896:				; UART Inititalization: 8 data bits, 1 stop bit, no parity
 897:				;   Input: BC = Baud rate divisor
 898:				; Affects: A
 899:				; Baud rate divisor = 3,686,400 / (16 * baud rate)
 900:				;    Baud: 300 | 1200 | 2400 | 3600 | 4800 | 9600 | 19200
 901:				; Divisor: 768 |  192 |   96 |   64 |   48 |   24 |    12
 902:     -	327A          	UartSet:                 
 903: 2723+7	327A  3E80    	    LD    A,$80        ; Set DLAB flag
 904: 2730+11	327C  D3E7    	    OUT   (UART_LCR),A
 905: 2741+4	327E  79      	    LD    A,C          ; Set Baud Rate divisor (Less Significant Byte)
 906: 2745+11	327F  D3E1    	    OUT   (UART_DLL),A
 907: 2756+4	3281  78      	    LD    A,B          ; Set Baud Rate divisor (Most Significant Byte)
 908: 2760+11	3282  D3E3    	    OUT   (UART_DLM),A 
 909: 2771+7	3284  3E03    	    LD    A,$03        ; 8-bit data, 1 stop-bit, no parity, reset DLAB flag
 910: 2778+11	3286  D3E7    	    OUT   (UART_LCR),A
 911: 2789+10	3288  C9      	    RET
 912:				
 913:				;------------------------------- (UART 16C450)
 914:				; Check if UART exist by writing/reading scratch register
 915:				; Output: A=0 and Z flag set only if UART exists
 916:				; Affects: A 
 917:     -	3289          	UartCheck:
 918: 2799+7	3289  3EAA    		LD    A,$AA             ; Test pattern 1
 919: 2806+11	328B  D3EF    		OUT   (UART_SCR),A      ; Write test bits to Scratch register
 920: 2817+11	328D  DBEF    		IN    A,(UART_SCR)      ; Read it back
 921: 2828+7	328F  EEAA    		XOR   $AA               ; If success, A=0 and Z flag is set
 922: 2835+7+5	3291  2008    		JR    NZ,UartCheckExit  ; Fail, get out
 923:					;----
 924: 2842+7	3293  3E55    		LD    A,$55             ; Test pattern 2
 925: 2849+11	3295  D3EF    		OUT   (UART_SCR),A      ; Write test bits to Scratch register
 926: 2860+11	3297  DBEF    		IN    A,(UART_SCR)      ; Read it back
 927: 2871+7	3299  EE55    		XOR   $55               ; If success, A=0 and Z flag is set	
 928:     -	329B          	UartCheckExit:
 929: 2878+10	329B  C9      		RET
 930:					
 931:				;------------------------------- (UART 16C450)
 932:				; Receive bytes from serial line
 933:				; Input: HL = destination memory block
 934:				;        DE = bytes to receive
 935:     -	329C          	UartRx:
 936: 2888+17	329C  CD8932  		CALL  UartCheck      ; Check if UART exist
 937: 2905+5+6	329F  C0      		RET   NZ             ; UART does not exist, abort
 938:     -	32A0          	UartRxWait:
 939: 2910+10	32A0  01FE7F  	    LD   BC,$7FFE        ; Check for Break Key (space scan group)
 940: 2920+12	32A3  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 941: 2932+8	32A5  CB47    		BIT  0,A             ; Check for 'space' keypress
 942: 2940+7+5	32A7  28F7    		JR   Z,UartRxWait    ; 'space' key pressed , wait release
 943:					;----
 944: 2947+4	32A9  F3      		DI                   ; Avoid interrupts
 945:     -	32AA          	UartRxLoop:
 946:				    ; Check for Break Key (relies on LD BC,$7FFE above)
 947: 2951+12	32AA  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 948: 2963+8	32AC  CB47    		BIT  0,A             ; Check for 'space' keypress
 949: 2971+7+5	32AE  280F    		JR   Z,UartExit      ; 'space' key pressed , Abort
 950:				    ; Check if new byte arrived
 951: 2978+11	32B0  DBEB    	    IN    A,(UART_LSR)   ; Read Line Status Register
 952: 2989+8	32B2  CB47    	    BIT   0,A            ; check UART ready to receive flag
 953: 2997+7+5	32B4  28F4    	    JR    Z,UartRxLoop   ; wait if not ready
 954:				    ; Get received byte
 955: 3004+11	32B6  DBE1    	    IN    A,(UART_DATA)  ; Get received byte
 956: 3015+7	32B8  77      		LD    (HL),A         ; Store it in memory
 957: 3022+6	32B9  23      		INC   HL             ; Point to next receive memory position
 958: 3028+6	32BA  1B      		DEC   DE             ; Countdown received bytes
 959: 3034+4	32BB  7A      		LD    A,D            ; Last byte ?
 960: 3038+4	32BC  B3      		OR    E
 961: 3042+7+5	32BD  20EB    		JR    NZ,UartRxLoop  ; No, Receive next byte
 962:     -	32BF          	UartExit:
 963: 3049+17	32BF  CD3603  	    CALL  scanKbrd       ; Wait for key release
 964: 3066+4	32C2  A7      	    AND   A
 965: 3070+7+5	32C3  20FA    		JR    NZ,UartExit
 966:				
 967: 3077+4	32C5  FB      	    EI                   ; Re-enable Interrupts
 968: 3081+10	32C6  C9      	    RET
 969:				
 970:				;------------------------------- (UART 16C450)
 971:				; Transmit bytes over serial line
 972:				; Input: HL = source memory block
 973:				;        DE = bytes to transmit
 974:     -	32C7          	UartTx:
 975: 3091+17	32C7  CD8932  		CALL  UartCheck      ; Check if UART exist
 976: 3108+5+6	32CA  C0      		RET   NZ             ; UART does not exist, abort
 977:     -	32CB          	UartTxWait:
 978: 3113+10	32CB  01FE7F  	    LD   BC,$7FFE        ; Check for Break Key
 979: 3123+12	32CE  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 980: 3135+8	32D0  CB47    		BIT  0,A             ; Check for 'space' keypress
 981: 3143+7+5	32D2  28F7    		JR   Z,UartTxWait    ; 'space' key pressed , wait release	
 982:				    ;----
 983: 3150+4	32D4  F3      		DI                   ; Avoid Interrupts
 984:     -	32D5          	UartTxLoop:
 985:				    ; Check for Break Key (relies on LD BC,$7FFE above)
 986: 3154+12	32D5  ED78    	    IN   A,(C)           ; Space key is in $7FFE key group, bit-0
 987: 3166+8	32D7  CB47    		BIT  0,A             ; Check for 'space' keypress
 988: 3174+7+5	32D9  28E4    		JR   Z,UartExit      ; 'space' key pressed , Abort
 989:				    ; Check if last byte was transmitted
 990: 3181+11	32DB  DBEB    	    IN   A,(UART_LSR)    ; Read Line Status Register
 991: 3192+8	32DD  CB6F    		BIT  5,A             ; check UART ready to send flag
 992: 3200+7+5	32DF  28F4    		JR   Z,UartTxLoop    ; wait if not ready
 993:				    ; Send a new byte
 994: 3207+7	32E1  7E      	    LD    A,(HL)         ; Get byte to transmit	
 995: 3214+11	32E2  D3E1    	    OUT   (UART_DATA),A  ; Send byte
 996: 3225+6	32E4  23      	    INC   HL             ; Point to next data byte
 997: 3231+6	32E5  1B      		DEC   DE             ; Countdown bytes transmitted
 998: 3237+4	32E6  7A      		LD    A,D            ; Last byte ?
 999: 3241+4	32E7  B3      		OR    E
1000: 3245+7+5	32E8  20EB    		JR    NZ,UartTxLoop  ; No, Transmit next byte
1001:					;----
1002: 3252+10	32EA  C3BF32  		JP    UartExit       ; Exit
1003:				
1004:				;##############################################################################
1005:     -	C413          	    .DEPHASE
1006:				;##############################################################################
1007:     -	C413          	dictExpEnd:
1008:				
1009:				;==============================================================================
1010:				; Alternate Character Set =====================================================
1011:				;==============================================================================
1012:     -	C413          	charSet:
1013:     -	C413  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	              00000000
1014:     -	C41B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	              00000000
1015:     -	C423  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	              00000000
1016:     -	C42B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	              00000000
1017:     -	C433  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	              0F0F0F0F
1018:     -	C43B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	              0F0F0F0F
1019:     -	C443  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	              0F0F0F0F
1020:     -	C44B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	              0F0F0F0F
1021:     -	C453  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	              00000000
1022:     -	C45B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	              00000000
1023:     -	C463  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	              00000000
1024:     -	C46B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	              00000000
1025:     -	C473  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	              0F0F0F0F
1026:     -	C47B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	              0F0F0F0F
1027:     -	C483  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	              0F0F0F0F
1028:     -	C48B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	              0F0F0F0F
1029:				    
1030:     -	C493  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	              00000000
1031:     -	C49B  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	              00000000
1032:     -	C4A3  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	              00000000
1033:     -	C4AB  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	              00000000
1034:     -	C4B3  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	              0F0F0F0F
1035:     -	C4BB  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	              0F0F0F0F
1036:     -	C4C3  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	              0F0F0F0F
1037:     -	C4CB  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	              0F0F0F0F
1038:     -	C4D3  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; blank
	              00000000
1039:     -	C4DB  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 000h, 000h, 000h, 000h  ; graphic 1
	              00000000
1040:     -	C4E3  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 000h, 000h, 000h, 000h  ; graphic 2
	              00000000
1041:     -	C4EB  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 000h, 000h, 000h, 000h  ; graphic 3
	              00000000
1042:     -	C4F3  00000000	    .BYTE   000h, 000h, 000h, 000h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 4
	              0F0F0F0F
1043:     -	C4FB  0F0F0F0F	    .BYTE   00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 5
	              0F0F0F0F
1044:     -	C503  F0F0F0F0	    .BYTE   0F0h, 0F0h, 0F0h, 0F0h, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 6
	              0F0F0F0F
1045:     -	C50B  FFFFFFFF	    .BYTE   0FFh, 0FFh, 0FFh, 0FFh, 00Fh, 00Fh, 00Fh, 00Fh  ; graphic 7
	              0F0F0F0F
1046:				    
1047:     -	C513  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; space
	              00000000
1048:     -	C51B  183C3C18	    .BYTE   018h, 03Ch, 03Ch, 018h, 018h, 000h, 018h, 000h  ; !
	              18001800
1049:     -	C523  36363600	    .BYTE   036h, 036h, 036h, 000h, 000h, 000h, 000h, 000h  ; "
	              00000000
1050:     -	C52B  36367F36	    .BYTE   036h, 036h, 07Fh, 036h, 07Fh, 036h, 036h, 000h  ; #
	              7F363600
1051:     -	C533  183E603C	    .BYTE   018h, 03Eh, 060h, 03Ch, 006h, 07Ch, 018h, 000h  ; $
	              067C1800
1052:     -	C53B  0063660C	    .BYTE   000h, 063h, 066h, 00Ch, 018h, 033h, 063h, 000h  ; %
	              18336300
1053:     -	C543  1C361C3B	    .BYTE   01Ch, 036h, 01Ch, 03Bh, 06Eh, 066h, 03Bh, 000h  ; &
	              6E663B00
1054:     -	C54B  18183000	    .BYTE   018h, 018h, 030h, 000h, 000h, 000h, 000h, 000h  ; '
	              00000000
1055:     -	C553  0C183030	    .BYTE   00Ch, 018h, 030h, 030h, 030h, 018h, 00Ch, 000h  ; (
	              30180C00
1056:     -	C55B  30180C0C	    .BYTE   030h, 018h, 00Ch, 00Ch, 00Ch, 018h, 030h, 000h  ; )
	              0C183000
1057:     -	C563  00663CFF	    .BYTE   000h, 066h, 03Ch, 0FFh, 03Ch, 066h, 000h, 000h  ; *
	              3C660000
1058:     -	C56B  0018187E	    .BYTE   000h, 018h, 018h, 07Eh, 018h, 018h, 000h, 000h  ; +
	              18180000
1059:     -	C573  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 018h, 018h, 030h  ; ,
	              00181830
1060:     -	C57B  0000007E	    .BYTE   000h, 000h, 000h, 07Eh, 000h, 000h, 000h, 000h  ; -
	              00000000
1061:     -	C583  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 018h, 018h, 000h  ; .
	              00181800
1062:     -	C58B  060C1830	    .BYTE   006h, 00Ch, 018h, 030h, 060h, 0C0h, 080h, 000h  ; /
	              60C08000
1063:				    
1064:     -	C593  3E63676F	    .BYTE   03Eh, 063h, 067h, 06Fh, 07Bh, 073h, 03Eh, 000h  ; 0
	              7B733E00
1065:     -	C59B  18381818	    .BYTE   018h, 038h, 018h, 018h, 018h, 018h, 07Eh, 000h  ; 1
	              18187E00
1066:     -	C5A3  3C66061C	    .BYTE   03Ch, 066h, 006h, 01Ch, 030h, 066h, 07Eh, 000h  ; 2
	              30667E00
1067:     -	C5AB  3C66061C	    .BYTE   03Ch, 066h, 006h, 01Ch, 006h, 066h, 03Ch, 000h  ; 3
	              06663C00
1068:     -	C5B3  0E1E3666	    .BYTE   00Eh, 01Eh, 036h, 066h, 07Fh, 006h, 00Fh, 000h  ; 4
	              7F060F00
1069:     -	C5BB  7E607C06	    .BYTE   07Eh, 060h, 07Ch, 006h, 006h, 066h, 03Ch, 000h  ; 5
	              06663C00
1070:     -	C5C3  1C30607C	    .BYTE   01Ch, 030h, 060h, 07Ch, 066h, 066h, 03Ch, 000h  ; 6
	              66663C00
1071:     -	C5CB  7E66060C	    .BYTE   07Eh, 066h, 006h, 00Ch, 018h, 018h, 018h, 000h  ; 7
	              18181800
1072:     -	C5D3  3C66663C	    .BYTE   03Ch, 066h, 066h, 03Ch, 066h, 066h, 03Ch, 000h  ; 8
	              66663C00
1073:     -	C5DB  3C66663E	    .BYTE   03Ch, 066h, 066h, 03Eh, 006h, 00Ch, 038h, 000h  ; 9
	              060C3800
1074:     -	C5E3  00181800	    .BYTE   000h, 018h, 018h, 000h, 000h, 018h, 018h, 000h  ; :
	              00181800
1075:     -	C5EB  00181800	    .BYTE   000h, 018h, 018h, 000h, 000h, 018h, 018h, 030h  ; ;
	              00181830
1076:     -	C5F3  0C183060	    .BYTE   00Ch, 018h, 030h, 060h, 030h, 018h, 00Ch, 000h  ; <
	              30180C00
1077:     -	C5FB  00007E00	    .BYTE   000h, 000h, 07Eh, 000h, 07Eh, 000h, 000h, 000h  ; =
	              7E000000
1078:     -	C603  30180C06	    .BYTE   030h, 018h, 00Ch, 006h, 00Ch, 018h, 030h, 000h  ; >
	              0C183000
1079:     -	C60B  3C66060C	    .BYTE   03Ch, 066h, 006h, 00Ch, 018h, 000h, 018h, 000h  ; ?
	              18001800
1080:				    
1081:     -	C613  3E636F6F	    .BYTE   03Eh, 063h, 06Fh, 06Fh, 06Fh, 060h, 03Ch, 000h  ; @
	              6F603C00
1082:     -	C61B  183C6666	    .BYTE   018h, 03Ch, 066h, 066h, 07Eh, 066h, 066h, 000h  ; A
	              7E666600
1083:     -	C623  7E33333E	    .BYTE   07Eh, 033h, 033h, 03Eh, 033h, 033h, 07Eh, 000h  ; B
	              33337E00
1084:     -	C62B  1E336060	    .BYTE   01Eh, 033h, 060h, 060h, 060h, 033h, 01Eh, 000h  ; C
	              60331E00
1085:     -	C633  7C363333	    .BYTE   07Ch, 036h, 033h, 033h, 033h, 036h, 07Ch, 000h  ; D
	              33367C00
1086:     -	C63B  7F31343C	    .BYTE   07Fh, 031h, 034h, 03Ch, 034h, 031h, 07Fh, 000h  ; E
	              34317F00
1087:     -	C643  7F31343C	    .BYTE   07Fh, 031h, 034h, 03Ch, 034h, 030h, 078h, 000h  ; F
	              34307800
1088:     -	C64B  1E336060	    .BYTE   01Eh, 033h, 060h, 060h, 067h, 033h, 01Fh, 000h  ; G
	              67331F00
1089:     -	C653  6666667E	    .BYTE   066h, 066h, 066h, 07Eh, 066h, 066h, 066h, 000h  ; H
	              66666600
1090:     -	C65B  3C181818	    .BYTE   03Ch, 018h, 018h, 018h, 018h, 018h, 03Ch, 000h  ; I
	              18183C00
1091:     -	C663  0F060606	    .BYTE   00Fh, 006h, 006h, 006h, 066h, 066h, 03Ch, 000h  ; J
	              66663C00
1092:     -	C66B  7333363C	    .BYTE   073h, 033h, 036h, 03Ch, 036h, 033h, 073h, 000h  ; K
	              36337300
1093:     -	C673  70303030	    .BYTE   070h, 030h, 030h, 030h, 031h, 033h, 07Fh, 000h  ; L
	              31337F00
1094:     -	C67B  63777F7F	    .BYTE   063h, 077h, 07Fh, 07Fh, 06Bh, 063h, 063h, 000h  ; M
	              6B636300
1095:     -	C683  63737B6F	    .BYTE   063h, 073h, 07Bh, 06Fh, 067h, 063h, 063h, 000h  ; N
	              67636300
1096:     -	C68B  1C366363	    .BYTE   01Ch, 036h, 063h, 063h, 063h, 036h, 01Ch, 000h  ; O
	              63361C00
1097:				    
1098:     -	C693  7E33333E	    .BYTE   07Eh, 033h, 033h, 03Eh, 030h, 030h, 078h, 000h  ; P
	              30307800
1099:     -	C69B  3C666666	    .BYTE   03Ch, 066h, 066h, 066h, 066h, 06Eh, 03Ch, 00Eh  ; Q
	              666E3C0E
1100:     -	C6A3  7E33333E	    .BYTE   07Eh, 033h, 033h, 03Eh, 036h, 033h, 073h, 000h  ; R
	              36337300
1101:     -	C6AB  3C667038	    .BYTE   03Ch, 066h, 070h, 038h, 00Eh, 066h, 03Ch, 000h  ; S
	              0E663C00
1102:     -	C6B3  7E5A1818	    .BYTE   07Eh, 05Ah, 018h, 018h, 018h, 018h, 03Ch, 000h  ; T
	              18183C00
1103:     -	C6BB  66666666	    .BYTE   066h, 066h, 066h, 066h, 066h, 066h, 07Eh, 000h  ; U
	              66667E00
1104:     -	C6C3  66666666	    .BYTE   066h, 066h, 066h, 066h, 066h, 03Ch, 018h, 000h  ; V
	              663C1800
1105:     -	C6CB  6363636B	    .BYTE   063h, 063h, 063h, 06Bh, 07Fh, 077h, 063h, 000h  ; W
	              7F776300
1106:     -	C6D3  6363361C	    .BYTE   063h, 063h, 036h, 01Ch, 01Ch, 036h, 063h, 000h  ; X
	              1C366300
1107:     -	C6DB  6666663C	    .BYTE   066h, 066h, 066h, 03Ch, 018h, 018h, 03Ch, 000h  ; Y
	              18183C00
1108:     -	C6E3  7F63460C	    .BYTE   07Fh, 063h, 046h, 00Ch, 019h, 033h, 07Fh, 000h  ; Z
	              19337F00
1109:     -	C6EB  3C303030	    .BYTE   03Ch, 030h, 030h, 030h, 030h, 030h, 03Ch, 000h  ; [
	              30303C00
1110:     -	C6F3  6030180C	    .BYTE   060h, 030h, 018h, 00Ch, 006h, 003h, 001h, 000h  ; \
	              06030100
1111:     -	C6FB  3C0C0C0C	    .BYTE   03Ch, 00Ch, 00Ch, 00Ch, 00Ch, 00Ch, 03Ch, 000h  ; ]
	              0C0C3C00
1112:     -	C703  081C3663	    .BYTE   008h, 01Ch, 036h, 063h, 000h, 000h, 000h, 000h  ; ^
	              00000000
1113:     -	C70B  00000000	    .BYTE   000h, 000h, 000h, 000h, 000h, 000h, 000h, 0FFh  ; underline
	              000000FF
1114:				    
1115:     -	C713  18180C00	    .BYTE   018h, 018h, 00Ch, 000h, 000h, 000h, 000h, 000h  ; `
	              00000000
1116:     -	C71B  00003C06	    .BYTE   000h, 000h, 03Ch, 006h, 03Eh, 066h, 03Bh, 000h  ; a
	              3E663B00
1117:     -	C723  7030303E	    .BYTE   070h, 030h, 030h, 03Eh, 033h, 033h, 06Eh, 000h  ; b
	              33336E00
1118:     -	C72B  00003C66	    .BYTE   000h, 000h, 03Ch, 066h, 060h, 066h, 03Ch, 000h  ; c
	              60663C00
1119:     -	C733  0E06063E	    .BYTE   00Eh, 006h, 006h, 03Eh, 066h, 066h, 03Bh, 000h  ; d
	              66663B00
1120:     -	C73B  00003C66	    .BYTE   000h, 000h, 03Ch, 066h, 07Eh, 060h, 03Ch, 000h  ; e
	              7E603C00
1121:     -	C743  1C363078	    .BYTE   01Ch, 036h, 030h, 078h, 030h, 030h, 078h, 000h  ; f
	              30307800
1122:     -	C74B  00003B66	    .BYTE   000h, 000h, 03Bh, 066h, 066h, 03Eh, 006h, 07Ch  ; g
	              663E067C
1123:     -	C753  7030363B	    .BYTE   070h, 030h, 036h, 03Bh, 033h, 033h, 073h, 000h  ; h
	              33337300
1124:     -	C75B  18003818	    .BYTE   018h, 000h, 038h, 018h, 018h, 018h, 03Ch, 000h  ; i
	              18183C00
1125:     -	C763  06000606	    .BYTE   006h, 000h, 006h, 006h, 006h, 066h, 066h, 03Ch  ; j
	              0666663C
1126:     -	C76B  70303336	    .BYTE   070h, 030h, 033h, 036h, 03Ch, 036h, 073h, 000h  ; k
	              3C367300
1127:     -	C773  38181818	    .BYTE   038h, 018h, 018h, 018h, 018h, 018h, 03Ch, 000h  ; l
	              18183C00
1128:     -	C77B  0000667F	    .BYTE   000h, 000h, 066h, 07Fh, 07Fh, 06Bh, 063h, 000h  ; m
	              7F6B6300
1129:     -	C783  00007C66	    .BYTE   000h, 000h, 07Ch, 066h, 066h, 066h, 066h, 000h  ; n
	              66666600
1130:     -	C78B  00003C66	    .BYTE   000h, 000h, 03Ch, 066h, 066h, 066h, 03Ch, 000h  ; o
	              66663C00
1131:				    
1132:     -	C793  00006E33	    .BYTE   000h, 000h, 06Eh, 033h, 033h, 03Eh, 030h, 078h  ; p
	              333E3078
1133:     -	C79B  00003B66	    .BYTE   000h, 000h, 03Bh, 066h, 066h, 03Eh, 006h, 00Fh  ; q
	              663E060F
1134:     -	C7A3  00006E3B	    .BYTE   000h, 000h, 06Eh, 03Bh, 033h, 030h, 078h, 000h  ; r
	              33307800
1135:     -	C7AB  00003E60	    .BYTE   000h, 000h, 03Eh, 060h, 03Ch, 006h, 07Ch, 000h  ; s
	              3C067C00
1136:     -	C7B3  08183E18	    .BYTE   008h, 018h, 03Eh, 018h, 018h, 01Ah, 00Ch, 000h  ; t
	              181A0C00
1137:     -	C7BB  00006666	    .BYTE   000h, 000h, 066h, 066h, 066h, 066h, 03Bh, 000h  ; u
	              66663B00
1138:     -	C7C3  00006666	    .BYTE   000h, 000h, 066h, 066h, 066h, 03Ch, 018h, 000h  ; v
	              663C1800
1139:     -	C7CB  0000636B	    .BYTE   000h, 000h, 063h, 06Bh, 07Fh, 07Fh, 036h, 000h  ; w
	              7F7F3600
1140:     -	C7D3  00006336	    .BYTE   000h, 000h, 063h, 036h, 01Ch, 036h, 063h, 000h  ; x
	              1C366300
1141:     -	C7DB  00006666	    .BYTE   000h, 000h, 066h, 066h, 066h, 03Eh, 006h, 07Ch  ; y
	              663E067C
1142:     -	C7E3  00007E4C	    .BYTE   000h, 000h, 07Eh, 04Ch, 018h, 032h, 07Eh, 000h  ; z
	              18327E00
1143:     -	C7EB  0E181870	    .BYTE   00Eh, 018h, 018h, 070h, 018h, 018h, 00Eh, 000h  ; {
	              18180E00
1144:     -	C7F3  18181818	    .BYTE   018h, 018h, 018h, 018h, 018h, 018h, 018h, 000h  ; |
	              18181800
1145:     -	C7FB  7018180E	    .BYTE   070h, 018h, 018h, 00Eh, 018h, 018h, 070h, 000h  ; }
	              18187000
1146:     -	C803  3B6E0000	    .BYTE   03Bh, 06Eh, 000h, 000h, 000h, 000h, 000h, 000h  ; ~
	              00000000
1147:     -	C80B  7E819DA1	    .BYTE   07Eh, 081h, 09Dh, 0A1h, 0A1h, 09Dh, 081h, 07Eh  ; (c)
	              A19D817E
1148:     -	C813          	charSetEnd:
1149:				
1150:				;==============================================================================
1151:     -	C813          	    .END



Statistics:

     4	passes
     0	jr promotions
   139	symbols
  2067	bytes

    45	macro calls
   273	macro bytes
     0	invented symbols



Symbol Table:

CF_DO_COLON    = EC3      3779
CHARRAM        =2C00      11264
DOCODE         =1A0E      6670
FORTH_LF       =3C47      15431
F_1PLUS        = E09      3593
F_2PLUS        = E13      3603
F_BASE         = 48A      1162
F_CFETCH       = 896      2198
F_CSTORE       = 8A5      2213
F_DIV          = D51      3409
F_DOT          = 9B3      2483
F_DUP          = 86B      2155
F_FETCH        = 8B3      2227
F_FIND         = 63D      1597
F_HERE         = 460      1120
F_MINUS        = DE1      3553
F_OVER         = 912      2322
F_PLUS         = DD2      3538
F_SEMICOLON    = 4B6      1206
F_STK_BYTE     =104B      4171
F_STK_WORD     =1011      4113
F_STORE        = 8C1      2241
F_SWAP         = 885      2181
PADEND         =2700      9984
PAGEDRAM       =8000      32768
PSG_REG        =FD        253
PSG_VAL        =FF        255
PSGenable      =07        7
PSGportA       =0E        14
PSGportB       =0F        15
RAMTOP         =3C18      15384
SCRNRAM        =2400      9216
SCRPOS         =3C1C      15388
SPARE          =3C3B      15419
UART_DATA      =E1        225
UART_DLL       =E1        225
UART_DLM       =E3        227
UART_IER       =E3        227
UART_IIR       =E5        229
UART_LCR       =E7        231
UART_LSR       =EB        235
UART_MCR       =E9        233
UART_MSR       =ED        237
UART_SCR       =EF        239
UFLOAT_NLF     =1D58      7512
UartCheck       3289      12937
UartCheckExit   329B      12955
UartExit        32BF      12991
UartRx          329C      12956
UartRxLoop      32AA      12970
UartRxWait      32A0      12960
UartSet         327A      12922
UartTx          32C7      12999
UartTxLoop      32D5      13013
UartTxWait      32CB      13003
XDICT          =3000      12288
XROM           =C000      49152
baudLink        3121      12577
baudName        311B      12571
blackLink       31C7      12743
blackName       31C0      12736
blueLink        31E5      12773
blueName        31DF      12767
borderLink      3169      12649
borderName      3161      12641
charSet         C413      50195
charSetEnd      C813      51219
clearScreen     C0DF      49375
clsLoop         C0E8      49384
cmove           325F      12895
cmoveLink       303C      12348
cmoveName       3035      12341
cmoveUp         3277      12919
colorBarLoop    C068      49256
countLink       3007      12295
countName       3000      12288
cyanLink        3202      12802
cyanName        31FC      12796
darkLink        324C      12876
darkName        3246      12870
depthLink       3069      12393
depthName       3062      12386
dictExp         C126      49446
dictExpEnd      C413      50195
drawBarPair     C048      49224
drawLongBar     C107      49415
drawShortBar    C0F9      49401
fill            3257      12887
fillLink        3052      12370
fillName        304C      12364
fontLink        3100      12544
fontName        30FA      12538
forthPopBC     = 84E      2126
greenLink       31F4      12788
greenName       31ED      12781
greyLink        31D7      12759
greyName        31D1      12753
hexLink         3089      12425
hexName         3084      12420
inkLink         3189      12681
inkName         3184      12676
longBarLoop     C109      49417
mpageLink       30C4      12484
mpageName       30BD      12477
paperLink       31A5      12709
paperName       319E      12702
printStr        C0F1      49393
psgrLink        30AE      12462
psgrName        30A8      12456
psgwLink        309B      12443
psgwName        3095      12437
pstoreLink      3018      12312
pstoreName      3014      12308
purpleLink      321F      12831
purpleName      3217      12823
questionLink    302C      12332
questionName    3029      12329
quitToForth    =9B        155
redBar          C11F      49439
redLink         320F      12815
redName         320A      12810
rxLink          3152      12626
rxName          314E      12622
scanKbrd       = 336      822
screenLink      30E1      12513
screenName      30D9      12505
shortBarLoop    C0FB      49403
stackByteAndFinish 31CC      12748
strII           C117      49431
strJupiter      C10F      49423
strYear         C11A      49434
txLink          313F      12607
txName          313B      12603
waitKeyPress    C0BD      49341
waitKeyRelease  C0B7      49335
whiteLink       323E      12862
whiteName       3237      12855
yellowLink      322F      12847
yellowName      3227      12839
